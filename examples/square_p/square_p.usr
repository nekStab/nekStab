c-----------------------------------------------------------------------
      subroutine nekstab_usrchk
      include 'SIZE'
      include 'TOTAL'
      if(istep.eq.0)then !change defaults

         xLspg = uparam(8); call bcast(xLspg , wdsize)
         xRspg = uparam(9); call bcast(xRspg , wdsize)

         k_dim = 100 ; call bcast(k_dim,isize)
         schur_tgt = 2 ; call bcast(schur_tgt,isize)
         maxmodes = 2 ; call bcast(maxmodes,isize)
         ifres = .false. ; call bcast(ifres,lsize)
         !ifvor = .true. ; call bcast(ifvor,lsize)
         !ifvox = .true. ; call bcast(ifvox,lsize)

         ifvans = .true. ; call bcast(ifvans,lsize)

         bst_skp = 0; call bcast(bst_skp,isize)
         bst_snp = 0 ; call bcast(bst_snp,isize)

      
      

      endif
      return 
      end subroutine nekstab_usrchk
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'

      real d_cube,d_sponge
      common /PENALZ/ d_cube,d_sponge
      real x0(3)
      save x0
      data x0 /3*0/
      integer bIDs(1), iobj_wall(1)
      
      call nekStab
      !call hpts
      
      !define objects for surface integrals
      ! if (istep.eq.0) then
      !    bIDs(1) = 1
      !    call create_obj(iobj_wall(1),bIDs,1)
      ! endif 
   
      !computing CL/CD -> printed in logfile -> use grep 
      !scale = 2.  ! Cd = F/(.5 rho U^2 ) = 2*F
      !if (mod(istep,10).eq.0) call torque_calc(scale,x0,.true.,.false.)
      
      spng_str2 = uparam(08) !penalization forcing strenght
      d_cube = 0.4 !hakf cube diamter ! must match the mesh
      d_sponge = 0.1 !sponge thickness 
      !D_TOTAL = D_CUBE + 2*D_SPONGE = 1.0 !
      if(istep.eq.0.AND.spng_str2.gt.0) then
        if(nid.eq.0)write(6,*)' Initializing penazaliton sponge...'
        if(nid.eq.0)write(6,*)' Solid cube diameter:',d_cube*2
        if(nid.eq.0)write(6,*)' Sponge layer tickness:',d_sponge
        if(nid.eq.0)write(6,*)' Sponge layer strenght:',spng_str2
        call spng_init2
      endif

      if(ifvans)call vansforcing          ! Soubroutine to calculate the forcing   

      return
      end
c-----------------------------------------------------------------------
      subroutine userf (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ffx = 0.0d0
      ffy = 0.0d0
      ffz = 0.0d0
      call nekStab_forcing(ffx,ffy,ffz,ix,iy,iz,ieg)

      if(ifvans)then
         ffx = ffx + vansforce_x(ix,iy,iz,ie) 
         ffy = ffy + vansforce_y(ix,iy,iz,ie)
         ffz = ffz + vansforce_z(ix,iy,iz,ie)
      else ! birkman model
         call penalization_forcing(ffx,ffy,ffz,ix,iy,iz,ieg)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e

      if (JP.eq.0) then         ! velocity
         e  = gllel(ieg)
         ux=1.0d0
         uy=0.0d0
         uz=0.0d0
         temp=0.0d0
      else                      ! perturbation
         ux = 0.0d0
         uy = 0.0d0
         uz = 0.0d0
         temp = 0.0d0
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e

      if (JP.eq.0) then         ! velocity
         e  = gllel(ieg)
         ux = 1.0d0
         uy = 0.0d0
         uz = 0.0d0

         if(x.gt.-2)temp=1.0d0 !cylinder with T

      else                      ! perturbation
         ux = 0.0d0
         uy = 0.0d0
         uz = 0.0d0
         temp = 0.0d0
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      udiff = 0.0d0
      utrans = 0.0d0
      return
      end
c-----------------------------------------------------------------------
      subroutine userq (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      qvol = 0.0d0
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2

      include 'SIZE'
      include 'TOTAL'
      common /USRBC/ bcflag(lx1,ly1,lz1,lelt)
      integer iel,ifc,id_face
      integer isideset1
      ntot = nx1*ny1*nz1*nelv	  
      call rzero(bcflag,ntot)


! W           2
! lower           3
! O           4
! upper           5
! v           6

      do iel=1,nelv
      do ifc=1,2*ndim
        id_face = bc(5,ifc,iel,1)
        if     (id_face.eq.6) then                   ! surface 1 for inlet
           cbc(ifc,iel,1) = 'v  '
        elseif (id_face.eq.4) then               ! surface 2 for outlet
           cbc(ifc,iel,1) = 'O  '
        elseif (id_face.eq.3) then               ! surface 3 for upper
           cbc(ifc,iel,1) = 'SYM'
        elseif (id_face.eq.5) then               ! surface 4 for lower
           cbc(ifc,iel,1) = 'SYM'
        elseif (id_face.eq.2) then               ! surface 5 for wall
           cbc(ifc,iel,1) = 'W  '

        endif
      enddo
      enddo

      cbc(:,:,2)=cbc(:,:,1)
      do iel=1,nelt
       do ifc = 1, 2*ndim
        if(cbc(ifc,iel,1).eq.'W  ')cbc(ifc,iel,2)='t  '
        if(cbc(ifc,iel,1).eq.'v  ')cbc(ifc,iel,2)='t  '
      enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      return
      end
c-----------------------------------------------------------------------
c PENALIZATION LAYER AROUND THE SQUARE CYLINDER      
c-----------------------------------------------------------------------
      subroutine penalization_forcing (ffx,ffy,ffz,ix,iy,iz,ieg)
      implicit none
      include 'SIZE'            !
      include 'INPUT'           ! IF3D
      include 'PARALLEL'        ! GLLEL
      include 'SOLN'            ! JP
      real ffx, ffy, ffz
      integer ix,iy,iz,ieg,iel,ip
      
      if(spng_str2.eq.0)return
      iel=gllel(ieg)
      ip=ix+nx1*(iy-1+ny1*(iz-1+nz1*(iel-1)))
      if (jp.eq.0) then
        ffx = ffx + spng_fun2(ip)*(spng_vr2(ip,1) - vx(ix,iy,iz,iel))
        ffy = ffy + spng_fun2(ip)*(spng_vr2(ip,2) - vy(ix,iy,iz,iel))
        if (if3d) ffz = ffz + spng_fun2(ip)*(spng_vr2(ip,ndim) - vz(ix,iy,iz,iel))
      else
        ffx = ffx - spng_fun2(ip)*vxp(ip,jp)
        ffy = ffy - spng_fun2(ip)*vyp(ip,jp)
        if(if3d) ffz = ffz - spng_fun2(ip)*vzp(ip,jp)
      endif
      
      return
      end subroutine
c-----------------------------------------------------------------------
      subroutine spng_init2
      implicit none
      include 'SIZE'
      include 'TOTAL'
      real d_cube,d_sponge
      common /PENALZ/ d_cube,d_sponge
      integer n
      n = nx1*ny1*nz1*nelv

                  spng_wl2(1)=d_sponge ! Sponge left section width
                  spng_wl2(2)=d_sponge
          if(IF3D)spng_wl2(3)=d_sponge

                  spng_wr2(1)=d_sponge! Sponge right section width
                  spng_wr2(2)=d_sponge
          if(IF3D)spng_wr2(3)=d_sponge

                 spng_dl2(1)=(4./4.)*d_sponge ! Sponge left drop/rise section width
                 spng_dl2(2)=(4./4.)*d_sponge
         if(IF3D)spng_dl2(3)=(4./4.)*d_sponge

                spng_dr2(1)=(4./4.)*d_sponge ! Sponge right drop/rise section width
                spng_dr2(2)=(4./4.)*d_sponge
        if(IF3D)spng_dr2(3)=(4./4.)*d_sponge

         if(nid.eq.0)then
            write(6,*)' Penalization width: ',d_sponge
         endif

      ! save reference field -> sponge value reference
      !call opcopy(spng_vr2(1,1),spng_vr2(1,2),spng_vr2(1,NDIM),vx,vy,vz) !only DNS
      call oprzero(spng_vr2(1,1),spng_vr2(1,2),spng_vr2(1,NDIM))
      call spng_set2 ! -> compute spng_fun

      return
      end
c-----------------------------------------------------------------------
      subroutine spng_set2 !set sponge function and refernece fields
      implicit none
      include 'SIZE'
      include 'TOTAL'

      real lcoord(LX1*LY1*LZ1*LELV)
      common /SCRUZ/ lcoord
      real d_cube,d_sponge
      common /PENALZ/ d_cube,d_sponge

      integer ierr, nhour, nmin, itmp, ntot, il, jl
      real rtmp, ltim, bmin(LDIM), bmax(LDIM)
      real xxmax, xxmax_c, xxmin, xxmin_c, arg
      real mth_stepf, glmax, spg_max
      logical ltmp, ltmp2

      ntot = NX1*NY1*NZ1*NELV

         call rzero(spng_fun2,ntot)
         ! for every dimension
         do il=1,NDIM

          if (spng_wl2(il).gt.0.0.or.spng_wr2(il).gt.0.0) then

             xxmax   = d_cube  !+ spng_wr2(il)! sponge beginning (rise at xmax; right)
             xxmin   = -d_cube !- spng_wl2(il)! end (drop at xmin; left)
             xxmax_c = xxmax   + spng_dr2(il)! beginnign of constant part (right)
             xxmin_c = xxmin   - spng_dl2(il)! beginnign of constant part (left)

             ! get SPNG_FUN
             if (xxmax.le.xxmin) then
                write(6,*)'Sponge too wide'
             else
                ! this should be done by pointers, but for now I avoid it
                if (il.eq.1) then
                   call copy(lcoord,XM1, ntot)
                elseif (il.eq.2) then
                   call copy(lcoord,YM1, ntot)
                elseif (il.eq.3) then
                   call copy(lcoord,ZM1, ntot)
                endif

                do jl=1,ntot
                   rtmp = lcoord(jl)
                   !if(rtmp.le.xxmin_c) then ! constant; xmin
                   !   rtmp=1.0d0
                   !elseif(rtmp.lt.xxmin) then ! fall; xmin
                   !   arg = (xxmin-rtmp)/spng_wl2(il)
                   !   rtmp = 0.0d0 !mth_stepf(arg)
                   !elseif (rtmp.le.xxmax) then ! zero
                   !   rtmp = 0.0d0
                   !else
                   if ( rtmp.ge.xxmin_c .and. rtmp.le.xxmax_c) then ! rise
                      !arg = (rtmp-xxmax)/spng_wr2(il)
                      rtmp = 0.0d0!mth_stepf(arg)
                   else    ! constant
                      rtmp = 1.0d0
                   endif
                   spng_fun2(jl)=max(spng_fun2(jl),rtmp)
                enddo

             endif  ! xxmax.le.xxmin
          endif  ! spng_w(il).gt.0.0
       enddo

      spg_max = glmax(spng_fun2,ntot)
      do jl=1,LX1*LY1*LZ1*LELV
        spng_fun2(jl)=(spg_max-spng_fun2(jl))*spng_str2
      enddo

      ltmp = ifto; ltmp2 = ifpo
      ifto = .true.; ifpo= .false.
      call outpost2(spng_vr2(1,1),spng_vr2(1,2),spng_vr2(1,NDIM),pr,spng_fun2,1,'PNL')
      ifto = ltmp; ifpo = ltmp2

      return
      end
c-----------------------------------------------------------------------
      subroutine vansforcing
      ! Volume-Averaged-NS based on ...
      implicit none
      include 'SIZE'
      include 'TOTAL'
      
      real, dimension(lx1,ly1,lz1,lelt) :: dum, vxy, vyy, vzy, oym1
      real, dimension(lx1,ly1,lz1,lelt) :: eps,dyeps,ddyeps,coeff,kappa,Dar,Fo
      real, dimension(lx1,ly1,lz1,lelt) :: absu
      real Reb,dph,deltab,epsc,glmax,gmax 
      integer e,k,j,i,lt,n
      logical ifto_sav, ifpo_sav

      n = nx1*ny1*nz1*nelt
      Reb    =    1.0d0/abs(param(2))
      dph    =    0.01d0
      deltab =    0.02d0
      epsc   =    0.6   ! porosity?

      if(nid.eq.0)write(6,*)' Computing VANS forcing...'

      call copy(oym1,spng_fun2,n) ! 1 porous 0 fluid
      call copy(coeff,oym1,n) ! 1 porous 0 fluid

      call gradm1(dum,vxy,dum,vx)
      call col2(vxy,bm1,n)
      call dssum(vxy,nx1,ny1,nz1)
      call col2(vxy,binvm1,n)
      
      call gradm1(dum,vyy,dum,vy)
      call col2(vyy,bm1,n)
      call dssum(vyy,nx1,ny1,nz1)
      call col2(vyy,binvm1,n)
      
      call gradm1(dum,vzy,dum,vz)
      call col2(vzy,bm1,n)
      call dssum(vzy,nx1,ny1,nz1)
      call col2(vzy,binvm1,n)
      
      do e=1,nelv
         DO K=1,NZ1
            DO J=1,NY1
               DO I=1,NX1
                  !oym1(i,j,k,e)=(spng_str2-oym1(i,j,k,e))

         if (oym1(i,j,k,e).eq.0.0) then ! fluid zone
         
            eps(i,j,k,e)    = 1.0d0
            dyeps(i,j,k,e)  = 0.0d0
            ddyeps(i,j,k,e) = 0.0d0
            coeff(i,j,k,e)  = 0.0d0
            Dar(i,j,k,e)    = 1.0d0
            Fo(i,j,k,e)     = 1.0d0
         
         elseif (oym1(i,j,k,e).gt.0.0 .and. oym1(i,j,k,e).le.deltab) then ! intermediary soze

            eps(i,j,k,e) = 0 !-6 *(epsc-1)*(oym1(i,j,k,e)/deltab)**5
      !   $                  -15 *(epsc-1)*(oym1(i,j,k,e)/deltab)**4
      !   $                   -10 *(epsc-1)*(oym1(i,j,k,e)/deltab)**3 +1

            dyeps(i,j,k,e) = 0 !-30 *(epsc-1)*(oym1(i,j,k,e)/deltab)**4*(1/deltab)
      !   $                     -60 *(epsc-1)*(oym1(i,j,k,e)/deltab)**3*(1/deltab)
      !   $                     -30 *(epsc-1)*(oym1(i,j,k,e)/deltab)**2*(1/deltab)

            ddyeps(i,j,k,e) = 0 !-120 *(epsc-1)*(oym1(i,j,k,e)/deltab)**3*(1/deltab)**2
      !   $                     -180 *(epsc-1)*(oym1(i,j,k,e)/deltab)**2*(1/deltab)**2
      !   $                     -60 *(epsc-1)*(oym1(i,j,k,e)/deltab)**1*(1/deltab)**2

            coeff(i,j,k,e) = 1
            kappa(i,j,k,e) = (dph**2 * eps(i,j,k,e)**3)/(180*(1-eps(i,j,k,e))**2)
            Dar(i,j,k,e) = kappa(i,j,k,e)
            Fo(i,j,k,e) = eps(i,j,k,e) * dph * Reb/(100*(1-eps(i,j,k,e)))
            usrdiv(i,j,k,e) = -(1/eps(i,j,k,e))*dyeps(i,j,k,e)*vy(i,j,k,e)
                     
            ! usrdiv(i,j,k,e) = 0
            ! write(*,*)'usrdiv(2,3,4,20)==============', usrdiv(2,3,4,20)
            ! write(*,*)'ddmax==============', ddmax
                     
         else ! vans zone

            eps(i,j,k,e)    = epsc
            dyeps(i,j,k,e)  = 0.0d0
            ddyeps(i,j,k,e) = 0.0d0
            coeff(i,j,k,e)  = 1.0d0
            kappa(i,j,k,e)  = (dph**2 * eps(i,j,k,e)**3) / (180*(1-eps(i,j,k,e))**2)
            Dar(i,j,k,e)    = kappa(i,j,k,e)
            Fo(i,j,k,e)     = eps(i,j,k,e) * dph * Reb / (100*(1-eps(i,j,k,e)))
                     
         endif
                  
               absu(i,j,k,e) = sqrt ( vx(i,j,k,e)**2  + vy(i,j,k,e)**2 + vz(i,j,k,e)**2)
                  
               vansforce_x(i,j,k,e)= coeff(i,j,k,e)*((-1/eps(i,j,k,e))
     $                 * dyeps(i,j,k,e)
     $                 * vx(i,j,k,e)*vy(i,j,k,e) +
     $                 (1/eps(i,j,k,e))*(1/Reb)
     $                 * dyeps(i,j,k,e)*vxy(i,j,k,e) -
     $                 (1/Reb)*eps(i,j,k,e)*(Fo(i,j,k,e)/Dar(i,j,k,e))
     $                 *   absu(i,j,k,e)*vx(i,j,k,e) +
     $                 (1/Reb)*vx(i,j,k,e)
     $                 *((ddyeps(i,j,k,e)/eps(i,j,k,e))
     $                 -eps(i,j,k,e)/Dar(i,j,k,e)))
                  
                  
               vansforce_y(i,j,k,e)= coeff(i,j,k,e)*((-1/eps(i,j,k,e))
     $                 * dyeps(i,j,k,e)
     $                 * vy(i,j,k,e)*vy(i,j,k,e) +
     $                 (1/eps(i,j,k,e))*(1/Reb)
     $                 * dyeps(i,j,k,e)*vyy(i,j,k,e) -
     $                 (1/Reb)*eps(i,j,k,e)*(Fo(i,j,k,e)/Dar(i,j,k,e))
     $                 *   absu(i,j,k,e)*vy(i,j,k,e) +
     $                 (1/Reb)*vy(i,j,k,e)
     $                 *((ddyeps(i,j,k,e)/eps(i,j,k,e))
     $                 -eps(i,j,k,e)/Dar(i,j,k,e)))
                  
                  
               vansforce_z(i,j,k,e)= coeff(i,j,k,e)*((-1/eps(i,j,k,e))
     $                 * dyeps(i,j,k,e)
     $                 * vz(i,j,k,e)*vy(i,j,k,e) +
     $                 (1/eps(i,j,k,e))*(1/Reb)
     $                 * dyeps(i,j,k,e)*vzy(i,j,k,e) -
     $                 (1/Reb)*eps(i,j,k,e)*(Fo(i,j,k,e)/Dar(i,j,k,e))
     $                 *   absu(i,j,k,e)*vz(i,j,k,e) +
     $                 (1/Reb)*vz(i,j,k,e)
     $                 *((ddyeps(i,j,k,e)/eps(i,j,k,e))
     $                 -eps(i,j,k,e)/Dar(i,j,k,e)))
                  
               !t(i,j,k,e,1)=vansforce_x(i,j,k,e)  
                  
               end do
            end do
         end do
      end do
      
         !write(*,*)'ym1(2,3,4,20)==============', ym1(2,3,4,20)
         !write(*,*)'eps(2,3,4,20)==============', eps(2,3,4,20)
         !write(*,*)'dyeps(2,3,4,20)==============', dyeps(2,3,4,20)
         !write(*,*)'ddyeps(2,3,4,20)==============', ddyeps(2,3,4,20)
         !write(*,*)'Dar(2,3,4,20)==============', Dar(2,3,4,20)
         !
         !write(*,*)'Fx(2,3,4,20)==============', vansforce_x(2,3,4,20)
         !write(*,*)'Fy(2,3,4,20)==============', vansforce_y(2,3,4,20)
         !write(*,*)'Fz(2,3,4,20)==============', vansforce_z(2,3,4,20)
      

      if ((istep.eq.0).OR.ifoutfld)then
         ifto_sav = ifto; ifpo_sav = ifpo
         ifvo=.false.; ifpo = .false.; ifto = .true. ! just outposting one field ... v's and p ignored 
         call outpost(vx,vy,vz,pr,oym1  ,'vs1')
         call outpost(vx,vy,vz,pr,eps   ,'vs2')
         call outpost(vx,vy,vz,pr,dyeps ,'vs3')
         call outpost(vx,vy,vz,pr,ddyeps,'vs4')
         call outpost(vx,vy,vz,pr,coeff ,'vs5')
         call outpost(vx,vy,vz,pr,Dar   ,'vs6')
         call outpost(vx,vy,vz,pr,Fo    ,'vs7')
         ifvo=.true.; ifto = .false.
         call outpost(vansforce_x,vansforce_y,vansforce_z,pr,t ,'vof')
         ifpo = ifpo_sav; ifto = ifto_sav
      endif


      return
      end
