c-----------------------------------------------------------------------
      subroutine nekstab_usrchk
      include 'SIZE'
      include 'TOTAL'
      if(istep.eq.0)then !change defaults

         xLspg = uparam(8); call bcast(xLspg , wdsize)
         xRspg = uparam(9); call bcast(xRspg , wdsize)

         k_dim = 100 ; call bcast(k_dim,isize)
         schur_tgt = 2 ; call bcast(schur_tgt,isize)
         maxmodes = 2 ; call bcast(maxmodes,isize)
         ifres = .false. ; call bcast(ifres,lsize)
         !ifvor = .true. ; call bcast(ifvor,lsize)
         !ifvox = .true. ; call bcast(ifvox,lsize)

         ifvans = .true. ; call bcast(ifvans,lsize)

         bst_skp = 0; call bcast(bst_skp,isize)
         bst_snp = 0 ; call bcast(bst_snp,isize)

      
      

      endif
      return 
      end subroutine nekstab_usrchk
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'

      real d_cube,d_sponge
      common /PENALZ/ d_cube,d_sponge
      real x0(3)
      save x0
      data x0 /3*0/
      integer bIDs(1), iobj_wall(1)
      
      call nekStab
      !call hpts
      
      !define objects for surface integrals
      ! if (istep.eq.0) then
      !    bIDs(1) = 1
      !    call create_obj(iobj_wall(1),bIDs,1)
      ! endif 
   
      !computing CL/CD -> printed in logfile -> use grep 
      !scale = 2.  ! Cd = F/(.5 rho U^2 ) = 2*F
      !if (mod(istep,10).eq.0) call torque_calc(scale,x0,.true.,.false.)
      
      spng_str2 = uparam(08) !penalization forcing strenght
      d_cube = 0.4 !hakf cube diamter ! must match the mesh
      d_sponge = 0.1 !sponge thickness 
      !D_TOTAL = D_CUBE + 2*D_SPONGE = 1.0 !
      if(istep.eq.0.AND.spng_str2.gt.0) then
        if(nid.eq.0)write(6,*)' Initializing penazaliton sponge...'
        if(nid.eq.0)write(6,*)' Solid cube diameter:',d_cube*2
        if(nid.eq.0)write(6,*)' Sponge layer tickness:',d_sponge
        if(nid.eq.0)write(6,*)' Sponge layer strenght:',spng_str2
        call spng_init2
      endif

      if(ifvans)call vansforcing          ! Soubroutine to calculate the forcing   

      return
      end
c-----------------------------------------------------------------------
      subroutine userf (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ffx = 0.0d0
      ffy = 0.0d0
      ffz = 0.0d0
      call nekStab_forcing(ffx,ffy,ffz,ix,iy,iz,ieg)

      if(ifvans)then
         ffx = ffx + vansforce_x(ix,iy,iz,ie) 
         ffy = ffy + vansforce_y(ix,iy,iz,ie)
         ffz = ffz + vansforce_z(ix,iy,iz,ie)
      else ! birkman model
         call penalization_forcing(ffx,ffy,ffz,ix,iy,iz,ieg)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e

      if (JP.eq.0) then         ! velocity
         e  = gllel(ieg)
         ux=1.0d0
         uy=0.0d0
         uz=0.0d0
         temp=0.0d0
      else                      ! perturbation
         ux = 0.0d0
         uy = 0.0d0
         uz = 0.0d0
         temp = 0.0d0
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e

      if (JP.eq.0) then         ! velocity
         e  = gllel(ieg)
         ux = 1.0d0
         uy = 0.0d0
         uz = 0.0d0

         if(x.gt.-2)temp=1.0d0 !cylinder with T

      else                      ! perturbation
         ux = 0.0d0
         uy = 0.0d0
         uz = 0.0d0
         temp = 0.0d0
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      udiff = 0.0d0
      utrans = 0.0d0
      return
      end
c-----------------------------------------------------------------------
      subroutine userq (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      qvol = 0.0d0
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2

      include 'SIZE'
      include 'TOTAL'
      common /USRBC/ bcflag(lx1,ly1,lz1,lelt)
      integer iel,ifc,id_face
      integer isideset1
      ntot = nx1*ny1*nz1*nelv	  
      call rzero(bcflag,ntot)


! W           2
! lower           3
! O           4
! upper           5
! v           6

      do iel=1,nelv
      do ifc=1,2*ndim
        id_face = bc(5,ifc,iel,1)
        if     (id_face.eq.6) then                   ! surface 1 for inlet
           cbc(ifc,iel,1) = 'v  '
        elseif (id_face.eq.4) then               ! surface 2 for outlet
           cbc(ifc,iel,1) = 'O  '
        elseif (id_face.eq.3) then               ! surface 3 for upper
           cbc(ifc,iel,1) = 'SYM'
        elseif (id_face.eq.5) then               ! surface 4 for lower
           cbc(ifc,iel,1) = 'SYM'
        elseif (id_face.eq.2) then               ! surface 5 for wall
           cbc(ifc,iel,1) = 'W  '

        endif
      enddo
      enddo

      cbc(:,:,2)=cbc(:,:,1)
      do iel=1,nelt
       do ifc = 1, 2*ndim
        if(cbc(ifc,iel,1).eq.'W  ')cbc(ifc,iel,2)='t  '
        if(cbc(ifc,iel,1).eq.'v  ')cbc(ifc,iel,2)='t  '
      enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      return
      end
c-----------------------------------------------------------------------
c PENALIZATION LAYER AROUND THE SQUARE CYLINDER      
c-----------------------------------------------------------------------
      subroutine penalization_forcing (ffx,ffy,ffz,ix,iy,iz,ieg)
      implicit none
      include 'SIZE'            !
      include 'INPUT'           ! IF3D
      include 'PARALLEL'        ! GLLEL
      include 'SOLN'            ! JP
      real ffx, ffy, ffz
      integer ix,iy,iz,ieg,iel,ip
      
      if(spng_str2.eq.0)return
      iel=gllel(ieg)
      ip=ix+nx1*(iy-1+ny1*(iz-1+nz1*(iel-1)))
      if (jp.eq.0) then
        ffx = ffx + spng_fun2(ip)*(spng_vr2(ip,1) - vx(ix,iy,iz,iel))
        ffy = ffy + spng_fun2(ip)*(spng_vr2(ip,2) - vy(ix,iy,iz,iel))
        if (if3d) ffz = ffz + spng_fun2(ip)*(spng_vr2(ip,ndim) - vz(ix,iy,iz,iel))
      else
        ffx = ffx - spng_fun2(ip)*vxp(ip,jp)
        ffy = ffy - spng_fun2(ip)*vyp(ip,jp)
        if(if3d) ffz = ffz - spng_fun2(ip)*vzp(ip,jp)
      endif
      
      return
      end subroutine
c-----------------------------------------------------------------------
      subroutine spng_init2
      implicit none
      include 'SIZE'
      include 'TOTAL'
      real d_cube,d_sponge
      common /PENALZ/ d_cube,d_sponge
      integer n
      n = nx1*ny1*nz1*nelv

                  spng_wl2(1)=d_sponge ! Sponge left section width
                  spng_wl2(2)=d_sponge
          if(IF3D)spng_wl2(3)=d_sponge

                  spng_wr2(1)=d_sponge! Sponge right section width
                  spng_wr2(2)=d_sponge
          if(IF3D)spng_wr2(3)=d_sponge

                 spng_dl2(1)=(4./4.)*d_sponge ! Sponge left drop/rise section width
                 spng_dl2(2)=(4./4.)*d_sponge
         if(IF3D)spng_dl2(3)=(4./4.)*d_sponge

                spng_dr2(1)=(4./4.)*d_sponge ! Sponge right drop/rise section width
                spng_dr2(2)=(4./4.)*d_sponge
        if(IF3D)spng_dr2(3)=(4./4.)*d_sponge

         if(nid.eq.0)then
            write(6,*)' Penalization width: ',d_sponge
         endif

      ! save reference field -> sponge value reference
      !call opcopy(spng_vr2(1,1),spng_vr2(1,2),spng_vr2(1,NDIM),vx,vy,vz) !only DNS
      call oprzero(spng_vr2(1,1),spng_vr2(1,2),spng_vr2(1,NDIM))
      call spng_set2 ! -> compute spng_fun

      return
      end
c-----------------------------------------------------------------------
      subroutine spng_set2 !set sponge function and refernece fields
      implicit none
      include 'SIZE'
      include 'TOTAL'

      real lcoord(LX1*LY1*LZ1*LELV)
      common /SCRUZ/ lcoord
      real d_cube,d_sponge
      common /PENALZ/ d_cube,d_sponge

      integer ierr, nhour, nmin, itmp, ntot, il, jl
      real rtmp, ltim, bmin(LDIM), bmax(LDIM)
      real xxmax, xxmax_c, xxmin, xxmin_c, arg
      real mth_stepf, glmax, spg_max
      logical ltmp, ltmp2

      ntot = NX1*NY1*NZ1*NELV

         call rzero(spng_fun2,ntot)
         ! for every dimension
         do il=1,NDIM

          if (spng_wl2(il).gt.0.0.or.spng_wr2(il).gt.0.0) then

             xxmax   = d_cube  !+ spng_wr2(il)! sponge beginning (rise at xmax; right)
             xxmin   = -d_cube !- spng_wl2(il)! end (drop at xmin; left)
             xxmax_c = xxmax   + spng_dr2(il)! beginnign of constant part (right)
             xxmin_c = xxmin   - spng_dl2(il)! beginnign of constant part (left)

             ! get SPNG_FUN
             if (xxmax.le.xxmin) then
                write(6,*)'Sponge too wide'
             else
                ! this should be done by pointers, but for now I avoid it
                if (il.eq.1) then
                   call copy(lcoord,XM1, ntot)
                elseif (il.eq.2) then
                   call copy(lcoord,YM1, ntot)
                elseif (il.eq.3) then
                   call copy(lcoord,ZM1, ntot)
                endif

                do jl=1,ntot
                   rtmp = lcoord(jl)
                   !if(rtmp.le.xxmin_c) then ! constant; xmin
                   !   rtmp=1.0d0
                   !elseif(rtmp.lt.xxmin) then ! fall; xmin
                   !   arg = (xxmin-rtmp)/spng_wl2(il)
                   !   rtmp = 0.0d0 !mth_stepf(arg)
                   !elseif (rtmp.le.xxmax) then ! zero
                   !   rtmp = 0.0d0
                   !else
                   if ( rtmp.ge.xxmin_c .and. rtmp.le.xxmax_c) then ! rise
                      !arg = (rtmp-xxmax)/spng_wr2(il)
                      rtmp = 0.0d0!mth_stepf(arg)
                   else    ! constant
                      rtmp = 1.0d0
                   endif
                   spng_fun2(jl)=max(spng_fun2(jl),rtmp)
                enddo

             endif  ! xxmax.le.xxmin
          endif  ! spng_w(il).gt.0.0
       enddo

      spg_max = glmax(spng_fun2,ntot)
      do jl=1,LX1*LY1*LZ1*LELV
        spng_fun2(jl)=(spg_max-spng_fun2(jl))*spng_str2
      enddo

      ltmp = ifto; ltmp2 = ifpo
      ifto = .true.; ifpo= .false.
      call outpost2(spng_vr2(1,1),spng_vr2(1,2),spng_vr2(1,NDIM),pr,spng_fun2,1,'PNL')
      ifto = ltmp; ifpo = ltmp2

      return
      end
c-----------------------------------------------------------------------
      subroutine vansforcing
      ! Volume-Averaged-NS based on ...
      implicit none
      include 'SIZE'
      include 'TOTAL'
      
      real, dimension(lx1,ly1,lz1,lelt) :: dum, vxy, vxx, vyy, vyx, vzy ,vzx , oym1
      real, dimension(lx1,ly1,lz1,lelt) :: eps,epsy,dyeps,ddyeps,epsx,dxeps,ddxeps,coeff,kappa,Dar,Fo
      real, dimension(lx1,ly1,lz1,lelt) :: absu
      real Reb,dph,deltab,epsc,glmax,gmax,y,x,cd1,cd2 
      integer e,k,j,i,lt,n,a,b,c,d
      logical ifto_sav, ifpo_sav

      n = nx1*ny1*nz1*nelt
      Reb    =    1/abs(param(2))
      dph    =    0.01d0
      deltab =    0.02
      epsc   =    0.65  ! porosity?

      if(nid.eq.0)write(6,*)' Computing VANS forcing...'

      call copy(oym1,spng_fun2,n) ! 1 porous 0 fluid
      call copy(coeff,ym1,xm1,n) ! 1 porous 0 fluid

      call gradm1(dum,vxy,dum,vx)
      call col2(vxy,bm1,n)
      call dssum(vxy,nx1,ny1,nz1)
      call col2(vxy,binvm1,n)

      call gradm1(dum,vxx,dum,vx)
      call col2(vxx,bm1,n)
      call dssum(vxx,nx1,ny1,nz1)
      call col2(vxx,binvm1,n)
      
      call gradm1(dum,vyy,dum,vy)
      call col2(vyy,bm1,n)
      call dssum(vyy,nx1,ny1,nz1)
      call col2(vyy,binvm1,n)

      call gradm1(dum,vyx,dum,vx)
      call col2(vyx,bm1,n)
      call dssum(vyx,nx1,ny1,nz1)
      call col2(vyx,binvm1,n)
      
      call gradm1(dum,vzy,dum,vz)
      call col2(vzy,bm1,n)
      call dssum(vzy,nx1,ny1,nz1)
      call col2(vzy,binvm1,n)

      call gradm1(dum,vzx,dum,vx)
      call col2(vzx,bm1,n)
      call dssum(vzx,nx1,ny1,nz1)
      call col2(vzx,binvm1,n)

      do e=1,nelv
         do k=1,NZ1
            do j=1,NY1
               do i=1,NX1

                  cd1=-0.5+deltab
                  cd2=0.5-deltab

                  if (ym1(i,j,k,e).ge.0.5 .and. ym1(i,j,k,e).le.-0.5 .and. xm1(i,j,k,e).le.-0.5 .and xm1(i,j,k,e).ge.0.5) then ! fluidzone
         
                     eps(i,j,k,e)    = 1
                     coeff(i,j,k,e)  = 0
                     Dar(i,j,k,e)    = 1
                     Fo(i,j,k,e)     = 1

                  elseif ((ym1(i,j,k,e).gt.cd2 .and. ym1(i,j,k,e).lt.cd1 .and. xm1(i,j,k,e).gt.cd2 .and. xm1(i,j,k,e).lt.cd1 )) then 
                     
                     a=-6 *(epsc-1)*(ym1(i,j,k,e)/deltab)**5
                     b=-15 *(epsc-1)*(ym1(i,j,k,e)/deltab)**4
                     c=-10 *(epsc-1)*(ym1(i,j,k,e)/deltab)**3
                     d=1
                     epsy(i,j,k,e)= a+b+c+d
                     a=-30 *(epsc-1)*(ym1(i,j,k,e)/deltab)**4*(1/deltab)
                     b=-60 *(epsc-1)*(ym1(i,j,k,e)/deltab)**3*(1/deltab)
                     c=-30 *(epsc-1)*(ym1(i,j,k,e)/deltab)**2*(1/deltab)
                     dyeps(i,j,k,e)=a+b+c
                     a=-120 *(epsc-1)*(ym1(i,j,k,e)/deltab)**3*(1/deltab)**2
                     b=-180 *(epsc-1)*(ym1(i,j,k,e)/deltab)**2*(1/deltab)**2 
                     c=-60 *(epsc-1)*(ym1(i,j,k,e)/deltab)**1*(1/deltab)**2              
                     ddyeps(i,j,k,e)=a+b+c

                     a=-6 *(epsc-1)*(xm1(i,j,k,e)/deltab)**5
                     b=-15 *(epsc-1)*(xm1(i,j,k,e)/deltab)**4
                     c=-10 *(epsc-1)*(xm1(i,j,k,e)/deltab)**3
                     d=1
                     epsx(i,j,k,e)= a+b+c+d
                     a=-30 *(epsc-1)*(xm1(i,j,k,e)/deltab)**4*(1/deltab)
                     b=-60 *(epsc-1)*(xm1(i,j,k,e)/deltab)**3*(1/deltab)
                     c=-30 *(epsc-1)*(xm1(i,j,k,e)/deltab)**2*(1/deltab)
                     dxeps(i,j,k,e)=a+b+c
                     a=-120 *(epsc-1)*(xm1(i,j,k,e)/deltab)**3*(1/deltab)**2
                     b=-180 *(epsc-1)*(xm1(i,j,k,e)/deltab)**2*(1/deltab)**2 
                     c=-60 *(epsc-1)*(xm1(i,j,k,e)/deltab)**1*(1/deltab)**2              
                     ddxeps(i,j,k,e)=a+b+c
                     

                     coeff(i,j,k,e) = 1
                     eps(i,j,k,e)=(epsx(i,j,k,e)+epsy(i,j,k,e))/2
                     kappa(i,j,k,e) = (dph**2 * eps(i,j,k,e)**3)/(180*(1-eps(i,j,k,e))**2)
                     Dar(i,j,k,e) = kappa(i,j,k,e)
                     Fo(i,j,k,e) = eps(i,j,k,e) * dph * Reb/(100*(1-eps(i,j,k,e)))
                     usrdiv(i,j,k,e) = -(1/eps(i,j,k,e))*(dyeps(i,j,k,e)*vy(i,j,k,e)+dxeps(i,j,k,e)*vx(i,j,k,e))
                     dxeps(i,j,k,e)=0
                     ddxeps(i,j,k,e)=0


                  else ! vans zone

                     eps(i,j,k,e)    = epsc
                     dyeps(i,j,k,e)  = 0.0d0
                     ddyeps(i,j,k,e) = 0.0d0
                     dxeps(i,j,k,e)  = 0.0d0
                     ddxeps(i,j,k,e) = 0.0d0
                     coeff(i,j,k,e)  = 1.0d0
                     !print*, "vans" !Verifying if calculating vans
                     kappa(i,j,k,e)  = (dph**2 * eps(i,j,k,e)**3) / (180*(1-eps(i,j,k,e))**2)
                     Dar(i,j,k,e)    = kappa(i,j,k,e)
                     Fo(i,j,k,e)     = eps(i,j,k,e) * dph * Reb / (100*(1-eps(i,j,k,e)))
                        
                     
                  endif
                  
                  absu(i,j,k,e) = sqrt ( vx(i,j,k,e)**2  + vy(i,j,k,e)**2 + vz(i,j,k,e)**2)
                  
                  a=vx(i,j,k,e)*vx(i,j,k,e)*dxeps(i,j,k,e)+vx(i,j,k,e)*vy(i,j,k,e)*dyeps(i,j,k,e)
                  b=dxeps(i,j,k,e)*vxx(i,j,k,e)+dyeps(i,j,k,e)*vxy(i,j,k,e)
                  c=absu(i,j,k,e)*vx(i,j,k,e)
                  d=ddxeps(i,j,k,e)+ddyeps(i,j,k,e)-(eps(i,j,k,e)/Dar(i,j,k,e))

                  vansforce_x(i,j,k,e)= coeff(i,j,k,e)*((-1/eps(i,j,k,e))*a 
     $                +(1/(eps(i,j,k,e)*Reb))*b
     $                -(1/Reb)*(Fo(i,j,k,e)/Dar(i,j,k,e))*eps(i,j,k,e)*c
     $                +(1/(Reb*eps(i,j,k,e)))*d*vx(i,j,k,e)) 

                  a=vy(i,j,k,e)*vx(i,j,k,e)*dxeps(i,j,k,e)+vy(i,j,k,e)*vy(i,j,k,e)*dyeps(i,j,k,e)
                  b=dxeps(i,j,k,e)*vyx(i,j,k,e)+dyeps(i,j,k,e)*vyy(i,j,k,e)
                  c=absu(i,j,k,e)*vy(i,j,k,e)
                  d=ddxeps(i,j,k,e)+ddyeps(i,j,k,e)-(eps(i,j,k,e)/Dar(i,j,k,e))

                  vansforce_y(i,j,k,e)= coeff(i,j,k,e)*((-1/eps(i,j,k,e))*a 
     $                +(1/(eps(i,j,k,e)*Reb))*b
     $                -(1/Reb)*(Fo(i,j,k,e)/Dar(i,j,k,e))*eps(i,j,k,e)*c
     $                +(1/(Reb*eps(i,j,k,e)))*d*vy(i,j,k,e)) 
                  
                  a=vz(i,j,k,e)*vx(i,j,k,e)*dxeps(i,j,k,e)+vz(i,j,k,e)*vy(i,j,k,e)*dyeps(i,j,k,e)
                  b=dxeps(i,j,k,e)*vzx(i,j,k,e)+dyeps(i,j,k,e)*vzy(i,j,k,e)
                  c=absu(i,j,k,e)*vz(i,j,k,e)
                  d=ddxeps(i,j,k,e)+ddyeps(i,j,k,e)-(eps(i,j,k,e)/Dar(i,j,k,e))

                  vansforce_z(i,j,k,e)= coeff(i,j,k,e)*((-1/eps(i,j,k,e))*a 
     $                +(1/(eps(i,j,k,e)*Reb))*b
     $                -(1/Reb)*(Fo(i,j,k,e)/Dar(i,j,k,e))*eps(i,j,k,e)*c
     $                +(1/(Reb*eps(i,j,k,e)))*d*vz(i,j,k,e)) 
                  
               t(i,j,k,e,1)=vansforce_x(i,j,k,e)  
                  
               end do
            end do
         end do
      end do
      
         !write(*,*)'ym1(2,3,4,20)==============', ym1(2,3,4,20)
         !write(*,*)'eps(2,3,4,20)==============', eps(2,3,4,20)
         !write(*,*)'dyeps(2,3,4,20)==============', dyeps(2,3,4,20)
         !write(*,*)'ddyeps(2,3,4,20)==============', ddyeps(2,3,4,20)
         !write(*,*)'Dar(2,3,4,20)==============', Dar(2,3,4,20)
         !
         !write(*,*)'Fx(2,3,4,20)==============', vansforce_x(2,3,4,20)
         !write(*,*)'Fy(2,3,4,20)==============', vansforce_y(2,3,4,20)
         !write(*,*)'Fz(2,3,4,20)==============', vansforce_z(2,3,4,20)
      

      if ((istep.eq.0).OR.ifoutfld)then
         ifto_sav = ifto; ifpo_sav = ifpo
         ifvo=.false.; ifpo = .false.; ifto = .true. ! just outposting one field ... v's and p ignored 
         call outpost(vx,vy,vz,pr,ym1  ,'vs1')
         call outpost(vx,vy,vz,pr,eps   ,'vs2')
         call outpost(vx,vy,vz,pr,dyeps ,'vs3')
         call outpost(vx,vy,vz,pr,ddyeps,'vs4')
         call outpost(vx,vy,vz,pr,coeff ,'vs5')
         call outpost(vx,vy,vz,pr,Dar   ,'vs6')
         call outpost(vx,vy,vz,pr,Fo    ,'vs7')
         call outpost(vx,vy,vz,pr,vansforce_x    ,'vs8')
         call outpost(vx,vy,vz,pr,vansforce_y   ,'vs9')
         call outpost(vx,vy,vz,pr,vansforce_z    ,'vs10')
         call outpost(vx,vy,vz,pr,xm1  ,'vs11')

         ifvo=.true.; ifto = .false.
         call outpost(vansforce_x,vansforce_y,vansforce_z,pr,t ,'vof')
         ifpo = ifpo_sav; ifto = ifto_sav
      endif


      return
      end

     