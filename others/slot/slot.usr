c-----------------------------------------------------------------------
      subroutine nekStab_usrchk
      implicit none
      include 'SIZE'
      include 'TOTAL'

      if(istep.eq.0)then !change defaults

        k_dim = 1 ; call bcast(k_dim,isize)
        !schur_tgt = 2 ; call bcast(schur_tgt,isize)
        !maxmodes = 2 ; call bcast(maxmodes,isize)

      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      implicit none
      include 'SIZE'
      include 'TOTAL'
      !common /mystuff/ dist(lx1,ly1,lz1,lelt)
      real xmax,xmin,zmax,zmin,tw,u_tau,Re_tau
      real glmax,glmin,iglsum
      integer       :: nmen
      integer, save :: iobj_wall,ntot
      real,save :: x0(3),A_w
      data x0 /0.0d0, 0.0d0, 0.0d0/

      !if(istep.eq.0) call gfldr("BF_jcf0.f00001")
      !if(istep.eq.0) call add_noise(vxp,vyp,vzp)
      call hpts
     
!      IF (uparam(01).lt.2) THEN
!       if (istep.eq.0) then

!!        if(nid.eq.0)open(13,file='wallstats.dat',status='unknown')
!        ntot = nx1*ny1*nz1*nelv
!        xmax = glmax(xm1,ntot)
!        xmin = glmin(xm1,ntot)
!        zmax = glmax(zm1,ntot)
!        zmin = glmin(zm1,ntot)
!        call create_obj(iobj_wall,4,1)
!        nmen = iglsum(nmember(iobj_wall),1)
!        if(nid.eq.0) write(6,*) 'obj_wall nmem:',nmen 
!        A_w = (xmax-xmin) * (zmax-zmin) - 4*atan(1.0d0) !removing pipe area
!
!       endif
!       if (mod(istep,100).eq.0) then
!
!        call torque_calc(1.0,x0,.false.,.false.) ! compute wall shear
!        tw     = dragx(iobj_wall) / A_w
!
!        if(nid.eq.0)then
!         u_tau  = sqrt(tw / param(1))
!         Re_tau = u_tau / param(2)
!         write(6,*)' tau_wall=',tw
!         write(6,*)' u_tau=',u_tau
!         write(6,*)' Re_tau=',Re_tau
!         write(13,"(4E15.7)")time,tw,u_tau,Re_tau
!        endif
!
      ! endif
      !ENDIF
      if(istep.eq.0) time=0.0d0 !reset time
      !if(istep.eq.0) call cheap_dist(dist,1,'W  ') !compute distances
      !if(istep.eq.0) call gfldr("1cyl0.fXXXXX") !interpolate old solution

      call nekStab

      return
      end
c-----------------------------------------------------------------------
      subroutine userf (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ffx = 0.0d0
      ffy = 0.0d0
      ffz = 0.0d0

      call nekStab_forcing(ffx,ffy,ffz,ix,iy,iz,ieg)

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e

      if (JP.eq.0) then         ! velocity
         e=gllel(ieg)
         ux=0.0d0
         uy=0.0d0
         if(y.ge.0)then
          ux=ubb(ix,iy,iz,e)
          uy=vbb(ix,iy,iz,e)
         endif
         uz=0.0d0
         temp=0.0d0
      else                      ! perturbation
         ux = 0.0d0
         uy = 0.0d0
         uz = 0.0d0
         temp = 0.0d0
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e

      real xor,zor,dc

      xor = 0.0
      zor = 0.0
      dc= sqrt((x-xor)**2+(z-zor)**2)

      if (JP.eq.0) then         ! velocity
         e  = gllel(ieg)
         ux = ubb(ix,iy,iz,e)
         !sb = vjb(ix,iy,iz,e)*sin(time*8.0d0*atan(1.0d0)*f_1)
         !smooth = 0.50d0+0.50d0*tanh((time-10.0d0))
         uy = vbb(ix,iy,iz,e) !+ sb*smooth
         
         temp=0.0d0
         if (y.lt.-2)then
          if(uparam(04).gt.0)then
           uy=womersley(dc*2,time) !pulsated periodic jet
          else 
           uy=uparam(06)*vjb(ix,iy,iz,e) !amplitude*parabolic profile
          endif
          temp=1.0d0
         endif
         uz = 0.0d0
      else                      ! perturbation
         ux = 0.0d0
         uy = 0.0d0
         uz = 0.0d0
         temp = 0.0d0
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      common/math/api
      common/pipe/alpha,omega,radius,uo_cent
      complex*16 ci,cz,cn,cd,ch,cf
      complex*16 CBJ0,CDJ0,CBJ1,CDJ1,CBY0,CDY0,CBY1,CDY1

      api = 4.0d0 * atan(1.0d0)
      omega = 2*api*uparam(04) ! 0.472*2
      radius = 0.50d0
 
      alpha = radius*sqrt(omega/param(2))
      ci = cmplx( cos(3.0d0*API/4.0d0), sin(3.0d0*API/4.0d0) )
      cz = cmplx(0,0)

      call CJY01(cz,cn,CDJ0,CBJ1,CDJ1,CBY0,CDY0,CBY1,CDY1)

      cz = alpha * ci
      call CJY01(cz,cd,CDJ0,CBJ1,CDJ1,CBY0,CDY0,CBY1,CDY1)

      cf = (1.0d0 - cn/cd)
 
      uo_cent = (uparam(06)*2.0d0) / real(cf)
 
       if(nid.eq.0)then
          write(*,*)'    alpha =', alpha 
          write(*,*)'    radius=', radius 
          write(*,*)'    nu   =' , anu 
          write(*,*)'    omega =', omega
          write(*,*)'    ci =', ci
          write(*,*)'    cz =', cz
          write(*,*)'    cn =', cn
          write(*,*)'    cd =', cd
       endif

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'
      integer iel,ifc

      call setbc(2,1,'O  ') ! outflow
      call setbc(3,1,'ON ') ! coflow
      call setbc(4,1,'W  ') ! lower wall
      call setbc(5,1,'v  ') ! inflow

      !if(ifheat)then
      !cbc(:,:,2)=cbc(:,:,1)
      !do iel=1,nelt
      ! do ifc = 1,2*ndim
      !  if(cbc(ifc,iel,1).eq.'v  ')cbc(ifc,iel,2)='t  '
      ! enddo
      !enddo
      !endif

      call set_blasius(ubb,vbb) ! Compute the Blasius profile for I.C.

      if(uparam(04).eq.0)call compute_jcf(vjb) !steady case compute BC profile
      
      !!!attention here --- not sure why -- it could avoid reading converged BF
      !ifbfcv = .true. !do not load prescibed base flow

      return
      end
c-----------------------------------------------------------------------
      subroutine compute_jcf(v_jet) !compute parabolic profile for jet in crossflow
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      real v_jet(1),xor,zor,D
      integer n,i
      n = nx1*ny1*nz1*nelv

      xor = 0.0d0
      zor = 0.0d0
      D = 1.0d0

      do i=1,n
       x = xm1(i,1,1,1)
       y = ym1(i,1,1,1)
       z = zm1(i,1,1,1)
        if(y.lt.0)then
         v_jet(i)=2.0d0*(1.0d0-4.0d0*(((x-xor)**2+(z-zor)**2)/D**2))
        else
         v_jet(i)=0.0d0
        endif
      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine set_blasius(ub,vb) ! Compute the Blasius profile
      include 'SIZE'
      include 'TOTAL'

      logical fg1,fg2,fg3
      real ub(1),vb(1)
      n = nx1*ny1*nz1*nelv
      
      fg1 = .true.;fg2 = .true.;fg3 = .true.

      visc = param(2)/param(1) !density / dynamic viscosity
      delta_star= uparam(7)

      u_0   = 1.0d0
      delta99_0 = (5.0d0/1.72080d0)*delta_star !2.9
      x_0 = (delta_star/1.7208d0)**2 / visc * u_0  ! Reference x
      x_inflow = x_0

      if(nid.eq.0)then
       write(6,*)'Re=',1/param(2)
       write(6,*)'visc=',visc
       write(6,*)'delta99_0=',delta99_0
       write(6,*)'delta_star=',delta_star
       write(6,*)'u_0=',u_0
       write(6,*)'x_inflow=',x_inflow
       write(6,*)'x min max=',xmn,xmx
       write(6,*)'y min max=',ymn,ymx
       write(6,*)'z min max=',zmn,zmx
      endif

      do i=1,n
         x = xm1(i,1,1,1)
         y = ym1(i,1,1,1)

         x_t = x_inflow + x
         rex = u_0 * x_t / visc
        
        if(x.eq.xmn)then
         if(fg1.eqv..true.)then
          write(6,*)'Inflow at x,Re_x,sqrt(Re_x)=',real(x_t,4),real(rex,4),real(sqrt(rex),4)
	  fg1=.false.!;call bcast(fg1, lsize)
         endif
        endif

        if(x.eq.0.0)then
         if(fg2.eqv..true.)then
          write(6,*)'Jet centerline x,Re_x,sqrt(Re_x)=',real(x_t,4),real(rex,4),real(sqrt(rex),4)
          fg2=.false.!;call bcast(fg2, lsize)
         endif
        endif

        if(x.eq.xmx)then
          if(fg3.eqv..true.)then
            write(6,*)'Outflow at x ,Re_x,sqrt(Re_x)=',real(x_t,4),real(rex,4),real(sqrt(rex),4)
          fg3=.false.!;call bcast(fg3, lsize)
         endif
        endif          
      
         eta = y*sqrt(rex)/x_t
         call blasius(ub(i),vb(i),eta,rex)

      enddo

      return
      end
c-----------------------------------------------------------------------
      real function womersley(r, t)
      common/math/api
      common/pipe/alpha,omega,radius,uo_cent
      real       r,t
      complex*16 ci,cz,cn,cd,ch,cf
      complex*16 CBJ0,CDJ0,CBJ1,CDJ1,CBY0,CDY0,CBY1,CDY1
      ci = cmplx( cos(3.0*API/4.0), sin(3.0*API/4.0) )
      cz = alpha * r * ci
      call CJY01(cz,cn,CDJ0,CBJ1,CDJ1,CBY0,CDY0,CBY1,CDY1)
      cz = alpha * ci
      call CJY01(cz,cd,CDJ0,CBJ1,CDJ1,CBY0,CDY0,CBY1,CDY1)
      ch = cmplx( cos(omega*t), sin(omega*t) )
      cf = (1.0 - cn/cd) * ch / cmplx(0.0, 1.0)
      womersley = real(cf) * uo_cent
      return
      end
c-----------------------------------------------------------------------
        SUBROUTINE CJY01(Z,CBJ0,CDJ0,CBJ1,CDJ1,CBY0,CDY0,CBY1,CDY1)
C
C       =======================================================
C       Purpose: Compute Bessel functions J0(z), J1(z), Y0(z), 
C                Y1(z), and their derivatives for a complex
C                argument
C       Input :  z --- Complex argument
C       Output:  CBJ0 --- J0(z)
C                CDJ0 --- J0'(z)
C                CBJ1 --- J1(z)
C                CDJ1 --- J1'(z)
C                CBY0 --- Y0(z)
C                CDY0 --- Y0'(z)
C                CBY1 --- Y1(z)
C                CDY1 --- Y1'(z)
C       =======================================================
C
        IMPLICIT DOUBLE PRECISION (A,B,E,P,R,W)
        IMPLICIT COMPLEX*16 (C,Z)
        DIMENSION A(12),B(12),A1(12),B1(12)
        PI=3.141592653589793D0
        EL=0.5772156649015329D0
        RP2=2.0D0/PI
        CI=(0.0D0,1.0D0)
        A0=CDABS(Z)
        Z2=Z*Z
        Z1=Z
        IF (A0.EQ.0.0D0) THEN
           CBJ0=(1.0D0,0.0D0)
           CBJ1=(0.0D0,0.0D0)
           CDJ0=(0.0D0,0.0D0)
           CDJ1=(0.5D0,0.0D0)
           CBY0=-(1.0D300,0.0D0)
           CBY1=-(1.0D300,0.0D0)
           CDY0=(1.0D300,0.0D0)
           CDY1=(1.0D300,0.0D0)
           RETURN
        ENDIF
        IF (REAL(Z).LT.0.0) Z1=-Z
        IF (A0.LE.12.0) THEN
           CBJ0=(1.0D0,0.0D0)
           CR=(1.0D0,0.0D0)
           DO 10 K=1,40
              CR=-0.25D0*CR*Z2/(K*K)
              CBJ0=CBJ0+CR
              IF (CDABS(CR).LT.CDABS(CBJ0)*1.0D-15) GO TO 15
10         CONTINUE
15         CBJ1=(1.0D0,0.0D0)
           CR=(1.0D0,0.0D0)
           DO 20 K=1,40
              CR=-0.25D0*CR*Z2/(K*(K+1.0D0))
              CBJ1=CBJ1+CR
              IF (CDABS(CR).LT.CDABS(CBJ1)*1.0D-15) GO TO 25
20         CONTINUE
25         CBJ1=0.5D0*Z1*CBJ1
           W0=0.0D0
           CR=(1.0D0,0.0D0)
           CS=(0.0D0,0.0D0)
           DO 30 K=1,40
              W0=W0+1.0D0/K
              CR=-0.25D0*CR/(K*K)*Z2
              CP=CR*W0
              CS=CS+CP
              IF (CDABS(CP).LT.CDABS(CS)*1.0D-15) GO TO 35
30         CONTINUE
35         CBY0=RP2*(CDLOG(Z1/2.0D0)+EL)*CBJ0-RP2*CS
           W1=0.0D0
           CR=(1.0D0,0.0D0)
           CS=(1.0D0,0.0D0)
           DO 40 K=1,40
              W1=W1+1.0D0/K
              CR=-0.25D0*CR/(K*(K+1))*Z2
              CP=CR*(2.0D0*W1+1.0D0/(K+1.0D0))
              CS=CS+CP
              IF (CDABS(CP).LT.CDABS(CS)*1.0D-15) GO TO 45
40         CONTINUE
45         CBY1=RP2*((CDLOG(Z1/2.0D0)+EL)*CBJ1-1.0D0/Z1-.25D0*Z1*CS)
        ELSE
           DATA A/-.703125D-01,.112152099609375D+00,
     &            -.5725014209747314D+00,.6074042001273483D+01,
     &            -.1100171402692467D+03,.3038090510922384D+04,
     &            -.1188384262567832D+06,.6252951493434797D+07,
     &            -.4259392165047669D+09,.3646840080706556D+11,
     &            -.3833534661393944D+13,.4854014686852901D+15/
           DATA B/ .732421875D-01,-.2271080017089844D+00,
     &             .1727727502584457D+01,-.2438052969955606D+02,
     &             .5513358961220206D+03,-.1825775547429318D+05,
     &             .8328593040162893D+06,-.5006958953198893D+08,
     &             .3836255180230433D+10,-.3649010818849833D+12,
     &             .4218971570284096D+14,-.5827244631566907D+16/
           DATA A1/.1171875D+00,-.144195556640625D+00,
     &             .6765925884246826D+00,-.6883914268109947D+01,
     &             .1215978918765359D+03,-.3302272294480852D+04,
     &             .1276412726461746D+06,-.6656367718817688D+07,
     &             .4502786003050393D+09,-.3833857520742790D+11,
     &             .4011838599133198D+13,-.5060568503314727D+15/
           DATA B1/-.1025390625D+00,.2775764465332031D+00,
     &             -.1993531733751297D+01,.2724882731126854D+02,
     &             -.6038440767050702D+03,.1971837591223663D+05,
     &             -.8902978767070678D+06,.5310411010968522D+08,
     &             -.4043620325107754D+10,.3827011346598605D+12,
     &             -.4406481417852278D+14,.6065091351222699D+16/
           K0=12
           IF (A0.GE.35.0) K0=10
           IF (A0.GE.50.0) K0=8
           CT1=Z1-.25D0*PI
           CP0=(1.0D0,0.0D0)
           DO 50 K=1,K0
50            CP0=CP0+A(K)*Z1**(-2*K)
           CQ0=-0.125D0/Z1
           DO 55 K=1,K0
55            CQ0=CQ0+B(K)*Z1**(-2*K-1)
           CU=CDSQRT(RP2/Z1)
           CBJ0=CU*(CP0*CDCOS(CT1)-CQ0*CDSIN(CT1))
           CBY0=CU*(CP0*CDSIN(CT1)+CQ0*CDCOS(CT1))
           CT2=Z1-.75D0*PI
           CP1=(1.0D0,0.0D0)
           DO 60 K=1,K0
60            CP1=CP1+A1(K)*Z1**(-2*K)
           CQ1=0.375D0/Z1
           DO 65 K=1,K0
65            CQ1=CQ1+B1(K)*Z1**(-2*K-1)
           CBJ1=CU*(CP1*CDCOS(CT2)-CQ1*CDSIN(CT2))
           CBY1=CU*(CP1*CDSIN(CT2)+CQ1*CDCOS(CT2))
        ENDIF
        IF (REAL(Z).LT.0.0) THEN
           IF (DIMAG(Z).LT.0.0) CBY0=CBY0-2.0D0*CI*CBJ0
           IF (DIMAG(Z).GT.0.0) CBY0=CBY0+2.0D0*CI*CBJ0
           IF (DIMAG(Z).LT.0.0) CBY1=-(CBY1-2.0D0*CI*CBJ1)
           IF (DIMAG(Z).GT.0.0) CBY1=-(CBY1+2.0D0*CI*CBJ1)
           CBJ1=-CBJ1
        ENDIF
        CDJ0=-CBJ1
        CDJ1=CBJ0-1.0D0/Z*CBJ1
        CDY0=-CBY1
        CDY1=CBY0-1.0D0/Z*CBY1
        RETURN
        END
