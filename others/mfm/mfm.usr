c-----------------------------------------------------------------------
      subroutine userchk
      implicit none
      include 'SIZE'
      include 'TOTAL'
      integer, parameter :: lt=lx1*ly1*lz1*lelt
      real int1(lt),int2(lt)
      real K,m,glsum,A1,A2,area2
      real, save :: m0
      integer n
      n = nx1*ny1*nz1*nelv

      !if(istep.eq.0) call gfldr("1cyl0.fXXXXX")
      !if(istep.eq.0) time = 0.0d0
      call nekStab

      !NOT USED HERE WHEN LINEAR
      !normalize scalar field 
      if(istep.eq.0) m0 = glsum(t(1,1,1,1,1),n)
      m = glsum(t(1,1,1,1,1),n)
      K = m0/m
      call cmult(t(1,1,1,1,1),K,n)

      uff = uparam(7) !input in .par file
   
      !compute mplitude 
      call nekStab_usrchk 
      call copy(int1,t(1,1,1,1,1),n)
      call add2sxy(int1,uff,ddtdx,param(8),n) !x := a*x + b*y 
      call col3(int2,ubb,vbb,n) !a := b*c
      call int_surf(A1,area2,int1)
      call int_surf(A2,area2,int2)
      AAA = A1/A2

      if(nid.eq.0)write(6,*)'K,A=',K,AAA!,A1,A2,area2
      if(istep.eq.0.and.nid.eq.0)open(unit=11,file='mfm.dat') !,status='unknown')
      write(11,'(3e15.7)')time,K,AAA
      !if(istep.eq.lastep.and.nid.eq.0)close(56)
 
      return
      end
c-----------------------------------------------------------------------
      subroutine nekStab_usrchk !called for linear and nonlinear cases
      implicit none
      include 'SIZE'
      include 'TOTAL'

      if(ifpert)then
       if(nid.eq.0)write(6,*)'computing transport term derivatives of p field'
       !ddudy and ddudz used as dummy arrays
       call gradm1 (ddudx,ddudy,ddudz ,vxp(:,1), nelv)
       call gradm1 (ddvdx,ddudy,ddudz ,vyp(:,1), nelv)
       call gradm1 (ddwdx,ddudy,ddudz ,vzp(:,1), nelv)
       call gradm1 (ddtdx,ddudy,ddudz ,tp(:,1,1), nelt)
      else 
       if(nid.eq.0)write(6,*)'computing transport term derivatives'
       call gradm1 (ddudx,ddudy,ddudz ,vx, nelv)
       call gradm1 (ddvdx,ddudy,ddudz ,vy, nelv)
       call gradm1 (ddwdx,ddudy,ddudz ,vz, nelv)
       call gradm1 (ddtdx,ddudy,ddudz ,t(1,1,1,1,1), nelt)
      endif
      call dsavg (ddudx);call dsavg (ddvdx)
      call dsavg (ddwdx);call dsavg (ddtdx)

      return
      end
c-----------------------------------------------------------------------
      subroutine userf (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'


      integer ip, iel
      real rtmp
 
      ffx = 0.0d0
      ffy = 0.0d0
      ffz = 0.0d0

      if(ifheat.and.uparam(06).gt.0)then
      iel = gllel(ieg)
      ip = ix + nx1*(iy-1+ny1*(iz-1+nz1*(iel-1)))
      if (jp .eq. 0) rtmp = t(ix, iy, iz, iel, 1)
      if (jp .eq. 1) rtmp = tp(ip, 1, 1)
      ffy=-rtmp
      endif
      
      call nekStab_forcing(ffx,ffy,ffz,ix,iy,iz,ieg) !sponge vel here
      call nfm_forcing(ffx,ffy,ffz,rtmp,ix,iy,iz,ieg) !coupling + extra terms here

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      real xf0,delta
      integer e,ntot
      
      xf0 = 5 !(xmax-xmin)*0.5d0
      delta = 4.0d0

      if (JP.eq.0) then ! velocity
         e  = gllel(ieg)
         ux= ubb(ix,iy,iz,e)*0.50d0*(1.0d0 - tanh((x-xf0)/delta))
         uy= 0.0d0
         uz= 0.0d0
         temp= vbb(ix,iy,iz,e)*0.50d0*(1.0d0 - tanh((x-xf0)/delta))
      else ! perturbation
         ux = 0.0d0
         uy = 0.0d0
         uz = 0.0d0
         temp = 0.0d0
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e

      if (JP.eq.0) then         ! velocity
         e  = gllel(ieg)
         ux= ubb(ix,iy,iz,e)*AAA
         uy= 0.0d0
         uz= 0.0d0
         temp= vbb(ix,iy,iz,e)
      else                      ! perturbation
         ux = 0.0d0
         uy = 0.0d0
         uz = 0.0d0
         temp = 0.0d0
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'
      real mmmmask(lx1,ly1,lz1,lelt)
      integer iel,ifc,ntot

      if(ifheat)then
      cbc(:,:,2)=cbc(:,:,1)
        do iel=1,nelt
        do ifc = 1,2*ndim
         if(cbc(ifc,iel,1).eq.'w  ')cbc(ifc,iel,2)='SYM'
         if(cbc(ifc,iel,1).eq.'v  ')cbc(ifc,iel,2)='t  '
        enddo
        enddo
      endif

      call compute_inflow(ubb,vbb) !compute inflow profile to variables
      return
      end
c-----------------------------------------------------------------------
      subroutine compute_inflow(ubb1,vbb1) !compute parabolic profile for jet in crossflow
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      real ubb1(1),vbb1(1)
      integer n,i
      n = nx1*ny1*nz1*nelv
      do i=1,n
       ubb1(i)=sin(8*atan(1.0d0)*ym1(i,1,1,1))
       vbb1(i)=0.5d0-0.5d0*tanh(8*atan(1.0d0)*(ym1(i,1,1,1)-0.5d0))
      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine nfm_forcing(ffx,ffy,ffz,temp,ix,iy,iz,ieg)
      implicit none
      include 'SIZE'
      include 'INPUT'           ! IF3D
      include 'PARALLEL'        ! GLLEL
      include 'SOLN'            ! JP
      real ffx,ffy,ffz,temp
      integer ix,iy,iz,ieg,iel,ip
      iel=gllel(ieg)
      ip=ix+nx1*(iy-1+ny1*(iz-1+nz1*(iel-1)))
      if (jp.eq.0) then !DNS
        if(ifheat)temp = temp +ddtdx(ip)*uff
        ffx = ffx +ddudx(ip)*uff
        ffy = ffy +ddvdx(ip)*uff
        if(if3d)ffz = ffz +ddwdx(ip)*uff
      else !PERT
        if(ifheat)temp = temp +ddtdx(ip)*uff
        ffx = ffx +ddudx(ip)*uff
        ffy = ffy +ddvdx(ip)*uff
        if(if3d)ffz = ffz +ddwdx(ip)*uff
      endif
      return
      end
c-----------------------------------------------------------------------
      subroutine int_surf(scal_in,area_2,scalar)
      include 'SIZE'
      include 'TOTAL'
      parameter (lt=lx1*ly1*lz1*lelt)
      real scalar(lt)
      integer e,f
      common /ctmp0/ work(lx1*ly1*lz1),one(lx1*ly1*lz1*lelt)
      n = lx1*ly1*lz1*nelt
      call rone(one,n)
      area_2  = 0.0d0
      scal_in = 0.0d0
      do e=1,nelv
      do f=1,2*ldim
         if (cbc(f,e,1).eq.'v  ') then
            area_e = facint_v(one   ,area,f,e)
            scal_e = facint_v(scalar,area,f,e) ! Your scalar here
            scal_in = scal_in + scal_e
            area_2  = area_2  + area_e
         endif
      enddo
      enddo
      area_2  = glsum(area_2 ,1)   ! Sum over all processors
      scal_in = glsum(scal_in,1)   ! Sum over all processors
      return
      end
c-----------------------------------------------------------------------
