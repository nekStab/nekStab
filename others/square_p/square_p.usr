c-----------------------------------------------------------------------
      subroutine nekstab_usrchk
      include 'SIZE'
      include 'TOTAL'
      if(istep.eq.0)then !change defaults

         xLspg = uparam(8); call bcast(xLspg , wdsize)
         xRspg = uparam(9); call bcast(xRspg , wdsize)

         k_dim = 100 ; call bcast(k_dim,isize)
         schur_tgt = 2 ; call bcast(schur_tgt,isize)
         maxmodes = 2 ; call bcast(maxmodes,isize)
         ifres = .false. ; call bcast(ifres,lsize)
         !ifvor = .true. ; call bcast(ifvor,lsize)
         !ifvox = .true. ; call bcast(ifvox,lsize)

         ifvans = .true. ; call bcast(ifvans,lsize)

         bst_skp = 0; call bcast(bst_skp,isize)
         bst_snp = 0 ; call bcast(bst_snp,isize)

      endif
      return 
      end subroutine nekstab_usrchk
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'

      real d_cube,d_sponge
      common /PENALZ/ d_cube,d_sponge
      real x0(3)
      save x0
      data x0 /3*0/
      integer bIDs(1), iobj_wall(1)
      
      call nekStab
      !call hpts
      
      !define objects for surface integrals
      ! if (istep.eq.0) then
      !    bIDs(1) = 1
      !    call create_obj(iobj_wall(1),bIDs,1)
      ! endif 
   
      !computing CL/CD -> printed in logfile -> use grep 
      !scale = 2.  ! Cd = F/(.5 rho U^2 ) = 2*F
      !if (mod(istep,10).eq.0) call torque_calc(scale,x0,.true.,.false.)
      
      spng_str2 = uparam(07) !penalization forcing strenght
      d_cube = 0.4 !hakf cube diamter ! must match the mesh
      d_sponge = 0.1 !sponge thickness 
      !D_TOTAL = D_CUBE + 2*D_SPONGE = 1.0 !
      if(istep.eq.0.AND.spng_str2.gt.0) then
        if(nid.eq.0)write(6,*)' Initializing penazaliton sponge...'
        if(nid.eq.0)write(6,*)' Solid cube diameter:',d_cube*2
        if(nid.eq.0)write(6,*)' Sponge layer tickness:',d_sponge
        if(nid.eq.0)write(6,*)' Sponge layer strenght:',spng_str2
        call spng_init2
      endif

      if(ifvans)then
         call oprzero(vansforce_x,vansforce_y,vansforce_z)
         call vans_forcing ! Soubroutine to calculate the forcing   
      endif
      return
      end
c-----------------------------------------------------------------------
      subroutine userf (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ffx = 0.0d0
      ffy = 0.0d0
      ffz = 0.0d0
      call nekStab_forcing(ffx,ffy,ffz,ix,iy,iz,ieg)

      if(ifvans.and.istep.gt.100)then
         ffx = ffx + vansforce_x(ix,iy,iz,ieg)
         ffy = ffy + vansforce_y(ix,iy,iz,ieg)
         ffz = ffz + vansforce_z(ix,iy,iz,ieg)
      else ! birkman model
         call penalization_forcing(ffx,ffy,ffz,ix,iy,iz,ieg)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e

      if (JP.eq.0) then         ! velocity
         e  = gllel(ieg)
         ux=1.0d0
         uy=0.0d0
         uz=0.0d0
         temp=0.0d0
      else                      ! perturbation
         ux = 0.0d0
         uy = 0.0d0
         uz = 0.0d0
         temp = 0.0d0
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e

      if (JP.eq.0) then         ! velocity
         e  = gllel(ieg)
         ux = 1.0d0
         uy = 0.0d0
         uz = 0.0d0

         if(x.gt.-2)temp=1.0d0 !cylinder with T

      else                      ! perturbation
         ux = 0.0d0
         uy = 0.0d0
         uz = 0.0d0
         temp = 0.0d0
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2

      include 'SIZE'
      include 'TOTAL'
      common /USRBC/ bcflag(lx1,ly1,lz1,lelt)
      integer iel,ifc,id_face
      integer isideset1
      ntot = nx1*ny1*nz1*nelv	  
      call rzero(bcflag,ntot)

      do iel=1,nelv
      do ifc=1,2*ndim
        id_face = bc(5,ifc,iel,1)
        if     (id_face.eq.6) then                   ! surface 1 for inlet
           cbc(ifc,iel,1) = 'v  '
        elseif (id_face.eq.4) then               ! surface 2 for outlet
           cbc(ifc,iel,1) = 'O  '
        elseif (id_face.eq.3) then               ! surface 3 for upper
           cbc(ifc,iel,1) = 'SYM'
        elseif (id_face.eq.5) then               ! surface 4 for lower
           cbc(ifc,iel,1) = 'SYM'
        elseif (id_face.eq.2) then               ! surface 5 for wall
           cbc(ifc,iel,1) = 'W  '

        endif
      enddo
      enddo

      cbc(:,:,2)=cbc(:,:,1)
      do iel=1,nelt
       do ifc = 1, 2*ndim
        if(cbc(ifc,iel,1).eq.'W  ')cbc(ifc,iel,2)='t  '
        if(cbc(ifc,iel,1).eq.'v  ')cbc(ifc,iel,2)='t  '
      enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
c     PENALIZATION LAYER AROUND THE SQUARE CYLINDER      
c-----------------------------------------------------------------------
      subroutine penalization_forcing (ffx,ffy,ffz,ix,iy,iz,ieg)
      implicit none
      include 'SIZE'            !
      include 'INPUT'           ! IF3D
      include 'PARALLEL'        ! GLLEL
      include 'SOLN'            ! JP
      real ffx, ffy, ffz
      integer ix,iy,iz,ieg,iel,ip
      
      if(spng_str2.eq.0)return
      iel=gllel(ieg)
      ip=ix+nx1*(iy-1+ny1*(iz-1+nz1*(iel-1)))
      if (jp.eq.0) then
        ffx = ffx + spng_fun2(ip)*(spng_vr2(ip,1) - vx(ix,iy,iz,iel))
        ffy = ffy + spng_fun2(ip)*(spng_vr2(ip,2) - vy(ix,iy,iz,iel))
        if (if3d) ffz = ffz + spng_fun2(ip)*(spng_vr2(ip,ndim) - vz(ix,iy,iz,iel))
      else
        ffx = ffx - spng_fun2(ip)*vxp(ip,jp)
        ffy = ffy - spng_fun2(ip)*vyp(ip,jp)
        if(if3d) ffz = ffz - spng_fun2(ip)*vzp(ip,jp)
      endif
      
      return
      end subroutine
c-----------------------------------------------------------------------
      subroutine spng_init2
      implicit none
      include 'SIZE'
      include 'TOTAL'
      real d_cube,d_sponge
      common /PENALZ/ d_cube,d_sponge
      integer n
      n = nx1*ny1*nz1*nelv

                  spng_wl2(1)=d_sponge ! Sponge left section width
                  spng_wl2(2)=d_sponge
          if(IF3D)spng_wl2(3)=d_sponge

                  spng_wr2(1)=d_sponge! Sponge right section width
                  spng_wr2(2)=d_sponge
          if(IF3D)spng_wr2(3)=d_sponge

                 spng_dl2(1)=(4./4.)*d_sponge ! Sponge left drop/rise section width
                 spng_dl2(2)=(4./4.)*d_sponge
         if(IF3D)spng_dl2(3)=(4./4.)*d_sponge

                spng_dr2(1)=(4./4.)*d_sponge ! Sponge right drop/rise section width
                spng_dr2(2)=(4./4.)*d_sponge
        if(IF3D)spng_dr2(3)=(4./4.)*d_sponge

         if(nid.eq.0)then
            write(6,*)' Penalization width: ',d_sponge
         endif

      ! save reference field -> sponge value reference
      !call opcopy(spng_vr2(1,1),spng_vr2(1,2),spng_vr2(1,NDIM),vx,vy,vz) !only DNS
      call oprzero(spng_vr2(1,1),spng_vr2(1,2),spng_vr2(1,NDIM))
      call spng_set2 ! -> compute spng_fun

      return
      end
c-----------------------------------------------------------------------
      subroutine spng_set2 !set sponge function and refernece fields
      implicit none
      include 'SIZE'
      include 'TOTAL'

      real lcoord(LX1*LY1*LZ1*LELV)
      common /SCRUZ/ lcoord
      real d_cube,d_sponge
      common /PENALZ/ d_cube,d_sponge

      integer ierr, nhour, nmin, itmp, ntot, il, jl
      real rtmp, ltim, bmin(LDIM), bmax(LDIM)
      real xxmax, xxmax_c, xxmin, xxmin_c, arg
      real mth_stepf, glmax, spg_max
      logical ltmp, ltmp2

      ntot = NX1*NY1*NZ1*NELV

         call rzero(spng_fun2,ntot)
         ! for every dimension
         do il=1,NDIM

         if (spng_wl2(il).gt.0.0.or.spng_wr2(il).gt.0.0) then

            xxmax   = d_cube  !+ spng_wr2(il)! sponge beginning (rise at xmax; right)
            xxmin   = -d_cube !- spng_wl2(il)! end (drop at xmin; left)
            xxmax_c = xxmax   + spng_dr2(il)! beginnign of constant part (right)
            xxmin_c = xxmin   - spng_dl2(il)! beginnign of constant part (left)

            ! get SPNG_FUN
            if (xxmax.le.xxmin) then
               write(6,*)'Sponge too wide'
            else
               ! this should be done by pointers, but for now I avoid it
               if (il.eq.1) then
                  call copy(lcoord,XM1, ntot)
               elseif (il.eq.2) then
                  call copy(lcoord,YM1, ntot)
               elseif (il.eq.3) then
                  call copy(lcoord,ZM1, ntot)
               endif

               do jl=1,ntot
                  rtmp = lcoord(jl)
                  !if(rtmp.le.xxmin_c) then ! constant; xmin
                  !   rtmp=1.0d0
                  !elseif(rtmp.lt.xxmin) then ! fall; xmin
                  !   arg = (xxmin-rtmp)/spng_wl2(il)
                  !   rtmp = 0.0d0 !mth_stepf(arg)
                  !elseif (rtmp.le.xxmax) then ! zero
                  !   rtmp = 0.0d0
                  !else
                  if ( rtmp.ge.xxmin_c .and. rtmp.le.xxmax_c) then ! rise
                     !arg = (rtmp-xxmax)/spng_wr2(il)
                     rtmp = 0.0d0!mth_stepf(arg)
                  else    ! constant
                     rtmp = 1.0d0
                  endif
                  spng_fun2(jl)=max(spng_fun2(jl),rtmp)
               enddo

            endif  ! xxmax.le.xxmin
         endif  ! spng_w(il).gt.0.0
      enddo

      spg_max = glmax(spng_fun2,ntot)
      do jl=1,LX1*LY1*LZ1*LELV
      spng_fun2(jl)=(spg_max-spng_fun2(jl))*spng_str2
      enddo

      ltmp = ifto; ltmp2 = ifpo
      ifto = .true.; ifpo= .false.
      call outpost2(spng_vr2(1,1),spng_vr2(1,2),spng_vr2(1,NDIM),pr,spng_fun2,1,'PNL')
      ifto = ltmp; ifpo = ltmp2

      return
      end
c-----------------------------------------------------------------------
      subroutine set_eps(tmp1,coord,a,b)
      implicit none
      include 'SIZE'
      include 'TOTAL'
      real tmp1(1),coord(1),a,b
      integer n,i
      n = nx1*ny1*nz1*nelv
      call rzero(tmp1,n)
      do i=1,n
         tmp1(i)=(0.5d0+0.5d0*tanh((coord(i)+a)/b))*(0.5d0-0.5d0*tanh((coord(i)-a)/b))
      enddo
      return
      end
c-----------------------------------------------------------------------
      function sech(x)
      IMPLICIT NONE
      REAL :: sech
      REAL, INTENT(IN) :: x
      sech=1.0d0/cosh(x)
      end function
c-----------------------------------------------------------------------
      subroutine set_deps(tmp1,coord,a,b)
      implicit none
      include 'SIZE'
      include 'TOTAL'
      real tmp1(1),coord(1),a,b,sech,x
      integer n,i
      n = nx1*ny1*nz1*nelv
      call rzero(tmp1,n)
      do i=1,n
         x=coord(i)
         tmp1(i)=(sech((x-a)/b)**2*(-0.250d0+0.250d0*tanh((-x-a)/b))+sech((-x-a)/b)**2*(0.250d0-0.250d0*tanh((x-a)/b)))/b
      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine set_d2eps(tmp1,coord,a,b)
      implicit none
      include 'SIZE'
      include 'TOTAL'
      real tmp1(1),coord(1),a,b,sech,x
      integer n,i
      n = nx1*ny1*nz1*nelv
      call rzero(tmp1,n)
      do i=1,n
         x=coord(i)
         tmp1(i)=(-0.5*sech((a+x)/b)**2*sech((x-a)/b)**2)/b**2-(sech((a+x)/b)**2*tanh((a+x)/b)*
     $           (0.5-0.5*tanh((x-a)/b)))/b**2+(sech((x-a)/b)**2*(0.5+0.5*tanh((a+x)/b))*tanh((x-a)/b))/b**2
      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine vans_forcing
      ! Volume-Averaged-NS based on ...
      implicit none
      include 'SIZE'
      include 'TOTAL'

      real, dimension(lx1,ly1,lz1,lelt) :: dum, vxy, vxx, vyy, vyx, vzy ,vzx, absu
      real, dimension(lx1,ly1,lz1,lelt), save :: eps,dxeps,dyeps,dzeps,ddxeps,ddyeps,ddzeps
      real, dimension(lx1,ly1,lz1,lelt), save :: coeff,Dar,Fo,coeffx,coeffy,coeffz
      real Reb,dph,deltab,epsc,glmax,gmax,y,x,cd1,cd2,halfdx,halfdy,halfdz
      integer e,k,j,i,lt,n,a,b,c,d
      logical ifto_sav, ifpo_sav

      n = nx1*ny1*nz1*nelt
      Reb    =    1.0d0/abs(param(2))
      dph    =    0.01 ! d_p -> mean particle diameter
      halfdx =    0.5  ! H ~ porous layer thickness 
      halfdy =    1
      halfdz =    0.5
      deltab =    0.04 ! delta_i = 0.02 - porous layer interface
      epsc   =    0.95  ! porosity

      if(nid.eq.0)write(6,*)' Computing VANS forcing...'

      if(istep.eq.0)then ! compute just once
      call set_eps(coeffx,xm1,halfdx,deltab)
      call set_eps(coeffy,ym1,halfdy,deltab)
      call set_eps(coeffz,zm1,halfdz,deltab)
      do i=1,n
         coeff(i,1,1,1)=coeffx(i,1,1,1)*coeffy(i,1,1,1)*coeffz(i,1,1,1)
         eps(i,1,1,1)=1.0d0-((1.0d0-epsc)*coeff(i,1,1,1))
         Dar(i,1,1,1) = ((dph**2)*(eps(i,1,1,1)**3))/(180*((1.0d0-eps(i,1,1,1))**2))
         Fo(i,1,1,1) = (eps(i,1,1,1)*dph*Reb) / (100.0d0*(1.0d0-eps(i,1,1,1)))
      enddo

      call set_deps(dxeps,xm1,halfdx,deltab)
      call col2(dxeps,coeffy,n)
      call col2(dxeps,coeffz,n)

      call set_deps(dyeps,ym1,halfdy,deltab)
      call col2(dyeps,coeffx,n)
      call col2(dyeps,coeffz,n)

      call set_deps(dzeps,zm1,halfdz,deltab)
      call col2(dzeps,coeffx,n)
      call col2(dzeps,coeffy,n)

      call set_d2eps(ddxeps,xm1,halfdx,deltab)
      call col2(ddxeps,coeffy,n)
      call col2(ddxeps,coeffz,n)

      call set_d2eps(ddyeps,ym1,halfdy,deltab)
      call col2(ddyeps,coeffx,n)
      call col2(ddyeps,coeffz,n)

      call set_d2eps(ddzeps,zm1,halfdz,deltab)
      call col2(ddzeps,coeffx,n)
      call col2(ddzeps,coeffy,n)

      endif 


      call gradm1(dum,vxy,dum,vx)
      call col2(vxy,bm1,n)
      call dssum(vxy,nx1,ny1,nz1)
      call col2(vxy,binvm1,n)

      call gradm1(dum,vxx,dum,vx)
      call col2(vxx,bm1,n)
      call dssum(vxx,nx1,ny1,nz1)
      call col2(vxx,binvm1,n)

      call gradm1(dum,vyy,dum,vy)
      call col2(vyy,bm1,n)
      call dssum(vyy,nx1,ny1,nz1)
      call col2(vyy,binvm1,n)

      call gradm1(dum,vyx,dum,vx)
      call col2(vyx,bm1,n)
      call dssum(vyx,nx1,ny1,nz1)
      call col2(vyx,binvm1,n)

      if(if3d)then
      call gradm1(dum,vzy,dum,vz)
      call col2(vzy,bm1,n)
      call dssum(vzy,nx1,ny1,nz1)
      call col2(vzy,binvm1,n)

      call gradm1(dum,vzx,dum,vx)
      call col2(vzx,bm1,n)
      call dssum(vzx,nx1,ny1,nz1)
      call col2(vzx,binvm1,n)
      endif

      do e=1,nelv
      do k=1,NZ1
      do j=1,NY1
      do i=1,NX1

               absu(i,j,k,e) = sqrt ( vx(i,j,k,e)**2  + vy(i,j,k,e)**2 + vz(i,j,k,e)**2)
               
               a=vx(i,j,k,e)*vx(i,j,k,e)*dxeps(i,j,k,e)+vx(i,j,k,e)*vy(i,j,k,e)*dyeps(i,j,k,e)
               b=dxeps(i,j,k,e)*vxx(i,j,k,e)+dyeps(i,j,k,e)*vxy(i,j,k,e)
               c=absu(i,j,k,e)*vx(i,j,k,e)
               d=ddxeps(i,j,k,e)+ddyeps(i,j,k,e)-(eps(i,j,k,e)/Dar(i,j,k,e))

               vansforce_x(i,j,k,e)= coeff(i,j,k,e)*((-1/eps(i,j,k,e))*a 
     $                +(1/(eps(i,j,k,e)*Reb))*b
     $                -(1/Reb)*(Fo(i,j,k,e)/Dar(i,j,k,e))*eps(i,j,k,e)*c
     $                +(1/(Reb*eps(i,j,k,e)))*d*vx(i,j,k,e)) 

               a=vy(i,j,k,e)*vx(i,j,k,e)*dxeps(i,j,k,e)+vy(i,j,k,e)*vy(i,j,k,e)*dyeps(i,j,k,e)
               b=dxeps(i,j,k,e)*vyx(i,j,k,e)+dyeps(i,j,k,e)*vyy(i,j,k,e)
               c=absu(i,j,k,e)*vy(i,j,k,e)
               d=ddxeps(i,j,k,e)+ddyeps(i,j,k,e)-(eps(i,j,k,e)/Dar(i,j,k,e))

               vansforce_y(i,j,k,e)= coeff(i,j,k,e)*((-1/eps(i,j,k,e))*a 
     $                +(1/(eps(i,j,k,e)*Reb))*b
     $                -(1/Reb)*(Fo(i,j,k,e)/Dar(i,j,k,e))*eps(i,j,k,e)*c
     $                +(1/(Reb*eps(i,j,k,e)))*d*vy(i,j,k,e)) 
               
               if(if3d)then
               a=vz(i,j,k,e)*vx(i,j,k,e)*dxeps(i,j,k,e)+vz(i,j,k,e)*vy(i,j,k,e)*dyeps(i,j,k,e)
               b=dxeps(i,j,k,e)*vzx(i,j,k,e)+dyeps(i,j,k,e)*vzy(i,j,k,e)
               c=absu(i,j,k,e)*vz(i,j,k,e)
               d=ddxeps(i,j,k,e)+ddyeps(i,j,k,e)-(eps(i,j,k,e)/Dar(i,j,k,e))

               vansforce_z(i,j,k,e)= coeff(i,j,k,e)*((-1/eps(i,j,k,e))*a 
     $                +(1/(eps(i,j,k,e)*Reb))*b
     $                -(1/Reb)*(Fo(i,j,k,e)/Dar(i,j,k,e))*eps(i,j,k,e)*c
     $                +(1/(Reb*eps(i,j,k,e)))*d*vz(i,j,k,e)) 
               endif   
      end do
      end do
      end do
      end do

      if ((istep.eq.0).OR.ifoutfld)then

      ifto_sav = ifto; ifpo_sav = ifpo
      ifvo=.false.; ifpo = .false.; ifto = .true. ! just outposting one field ... v's and p ignored 
      call outpost(vx,vy,vz,pr,eps   ,'d0s')
      call outpost(vx,vy,vz,pr,coeff ,'cof')
      call outpost(vx,vy,vz,pr,Dar   ,'Dar')
      call outpost(vx,vy,vz,pr,Fo    ,'Fo_')
      ifvo=.true.; ifto = .false.
      call outpost(vansforce_x,vansforce_y,vansforce_z,pr,t ,'VSf')
      call outpost(dxeps,dyeps,dzeps,pr,t ,'d1s')
      call outpost(ddxeps,ddyeps,ddzeps,pr,t,'d2s')
      ifpo = ifpo_sav; ifto = ifto_sav
      endif

      return
      end subroutine vans_forcing
c-----------------------------------------------------------------------