c-----------------------------------------------------------------------
      subroutine nekStab_usrchk
      implicit none
      include 'SIZE'
      include 'TOTAL'
      if(istep.eq.0)then !change defaults

        k_dim = 1 ; call bcast(k_dim,isize)
        !schur_tgt = 2 ; call bcast(schur_tgt,isize)
        !maxmodes = 2 ; call bcast(maxmodes,isize)

      endif
      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      implicit none
      include 'SIZE'
      include 'TOTAL'
      !common /mystuff/ dist(lx1,ly1,lz1,lelt)
      real xmax,xmin,zmax,zmin,tw,u_tau,Re_tau
      real glmax,glmin,iglsum
      integer       :: nmen
      integer, save :: iobj_wall,ntot
      real,save :: x0(3),A_w
      data x0 /0.0d0, 0.0d0, 0.0d0/

      !if(istep.eq.0) call gfldr("BF_jcf0.f00001")
      !if(istep.eq.0) call add_noise(vxp,vyp,vzp)
     
!      IF (uparam(01).lt.2) THEN
!       if (istep.eq.0) then

!!        if(nid.eq.0)open(13,file='wallstats.dat',status='unknown')
!        ntot = nx1*ny1*nz1*nelv
!        xmax = glmax(xm1,ntot)
!        xmin = glmin(xm1,ntot)
!        zmax = glmax(zm1,ntot)
!        zmin = glmin(zm1,ntot)
!        call create_obj(iobj_wall,4,1)
!        nmen = iglsum(nmember(iobj_wall),1)
!        if(nid.eq.0) write(6,*) 'obj_wall nmem:',nmen 
!        A_w = (xmax-xmin) * (zmax-zmin) - 4*atan(1.0d0) !removing pipe area
!
!       endif
!       if (mod(istep,100).eq.0) then
!        call torque_calc(1.0,x0,.false.,.false.) ! compute wall shear
!        tw     = dragx(iobj_wall) / A_w
!        if(nid.eq.0)then
!         u_tau  = sqrt(tw / param(1))
!         Re_tau = u_tau / param(2)
!         write(6,*)' tau_wall=',tw
!         write(6,*)' u_tau=',u_tau
!         write(6,*)' Re_tau=',Re_tau
!         write(13,"(4E15.7)")time,tw,u_tau,Re_tau
!        endif
      ! endif
      !ENDIF
      !if(istep.eq.0) call cheap_dist(dist,1,'W  ') !compute distances
      !if(istep.eq.0) call gfldr("1cyl0.fXXXXX") !interpolate old solution

      if(istep.eq.0) time=0.0d0 !reset time
      call nekStab
      call hpts
      call fst

      return
      end
c-----------------------------------------------------------------------
      subroutine userf (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ffx = 0.0d0
      ffy = 0.0d0
      ffz = 0.0d0
      call nekStab_forcing(ffx,ffy,ffz,ix,iy,iz,ieg)

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e

      if (JP.eq.0) then         ! velocity
         e=gllel(ieg)
         ux=0.0d0
         uy=0.0d0
         if(y.ge.0)then
          ux=ubb(ix,iy,iz,e)
          uy=vbb(ix,iy,iz,e)
         endif
         uz=0.0d0
         temp=0.0d0
      else                      ! perturbation
         ux = 0.0d0
         uy = 0.0d0
         uz = 0.0d0
         temp = 0.0d0
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e
      real xor,zor,dc,smooth_inflow,smooth_jet

      xor = 0.0d0
      zor = 0.0d0
      dc= sqrt((x-xor)**2+(z-zor)**2)
      smooth_inflow = 0.50d0+0.50d0*tanh((time-20.0d0))
      smooth_jet = 0.50d0+0.50d0*tanh((time-1.0d0))

      if (JP.eq.0) then ! velocity
         e  = gllel(ieg)
         ux = ubb(ix,iy,iz,e)  + fst_uin(ix,iy,iz,e)*smooth_inflow
         !sb = vjb(ix,iy,iz,e)*sin(time*8.0d0*atan(1.0d0)*f_1)
         uy = vbb(ix,iy,iz,e)  + fst_vin(ix,iy,iz,e)*smooth_inflow !+ sb*smooth
         temp=0.0d0
         if (y.lt.-2)then
            uy = 0.0d0
            ux = 0.0d0
            uz = 0.0d0
          if(uparam(04).gt.0)then
           uy=womersley(dc*2,time)*smooth_jet !pulsated periodic jet
          else 
           uy=uparam(06)*vjb(ix,iy,iz,e)*smooth_jet !amplitude*parabolic profile
          endif
          temp=1.0d0
         endif
         uz = 0.0d0            + fst_win(ix,iy,iz,e)*smooth_inflow
      else ! perturbation
         ux = 0.0d0
         uy = 0.0d0
         uz = 0.0d0
         temp = 0.0d0
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      common/math/api
      common/pipe/alpha,omega,radius,uo_cent
      complex*16 ci,cz,cn,cd,ch,cf
      complex*16 CBJ0,CDJ0,CBJ1,CDJ1,CBY0,CDY0,CBY1,CDY1

      api = 4.0d0 * atan(1.0d0)
      omega = 2*api*uparam(04) ! 0.472*2
      radius = 0.50d0
 
      alpha = radius*sqrt(omega/param(2))
      ci = cmplx( cos(3.0d0*API/4.0d0), sin(3.0d0*API/4.0d0) )
      cz = cmplx(0,0)

      call CJY01(cz,cn,CDJ0,CBJ1,CDJ1,CBY0,CDY0,CBY1,CDY1)

      cz = alpha * ci
      call CJY01(cz,cd,CDJ0,CBJ1,CDJ1,CBY0,CDY0,CBY1,CDY1)

      cf = (1.0d0 - cn/cd)
 
      uo_cent = (uparam(06)*2.0d0) / real(cf)
 
       if(nid.eq.0)then
          write(*,*)'    alpha =', alpha 
          write(*,*)'    radius=', radius 
          write(*,*)'    nu   =' , anu 
          write(*,*)'    omega =', omega
          write(*,*)'    ci =', ci
          write(*,*)'    cz =', cz
          write(*,*)'    cn =', cn
          write(*,*)'    cd =', cd
       endif

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'
      integer iel,ifc

      call setbc(2,1,'O  ') ! outflow
      call setbc(3,1,'ON ') ! coflow
      call setbc(4,1,'W  ') ! lower wall
      call setbc(5,1,'v  ') ! inflow

      !if(ifheat)then
      !cbc(:,:,2)=cbc(:,:,1)
      !do iel=1,nelt
      ! do ifc = 1,2*ndim
      !  if(cbc(ifc,iel,1).eq.'v  ')cbc(ifc,iel,2)='t  '
      ! enddo
      !enddo
      !endif

      call set_blasius(ubb,vbb) ! Compute the Blasius profile for I.C.
      if(uparam(04).eq.0)call compute_jcf(vjb) !steady case compute BC profile

      return
      end
c-----------------------------------------------------------------------
      subroutine compute_jcf(v_jet) !compute parabolic profile for jet in crossflow
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      real v_jet(1),xor,zor,D
      integer n,i
      n = nx1*ny1*nz1*nelv

      xor = 0.0d0
      zor = 0.0d0
      D = 1.0d0

      do i=1,n
       x = xm1(i,1,1,1)
       y = ym1(i,1,1,1)
       z = zm1(i,1,1,1)
        if(y.lt.0)then
         v_jet(i)=2.0d0*(1.0d0-4.0d0*(((x-xor)**2+(z-zor)**2)/D**2))
        else
         v_jet(i)=0.0d0
        endif
      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine set_blasius(ub,vb) ! Compute the Blasius profile
      include 'SIZE'
      include 'TOTAL'

      logical fg1,fg2,fg3
      real ub(1),vb(1)
      n = nx1*ny1*nz1*nelv
      
      fg1 = .true.;fg2 = .true.;fg3 = .true.

      visc = param(2)/param(1) !density / dynamic viscosity
      delta_star= uparam(7)

      u_0   = 1.0d0
      delta99_0 = (5.0d0/1.72080d0)*delta_star !2.9
      x_0 = (delta_star/1.7208d0)**2 / visc * u_0  ! Reference x
      x_inflow = x_0

      if(nid.eq.0)then
       write(6,*)'Re=',1/param(2)
       write(6,*)'visc=',visc
       write(6,*)'delta99_0=',delta99_0
       write(6,*)'delta_star=',delta_star
       write(6,*)'u_0=',u_0
       write(6,*)'x_inflow=',x_inflow
       write(6,*)'x min max=',xmn,xmx
       write(6,*)'y min max=',ymn,ymx
       write(6,*)'z min max=',zmn,zmx
      endif

      do i=1,n
         x = xm1(i,1,1,1)
         y = ym1(i,1,1,1)

         x_t = x_inflow + x
         rex = u_0 * x_t / visc
        
        if(x.eq.xmn)then
         if(fg1.eqv..true.)then
          write(6,*)'Inflow at x,Re_x,sqrt(Re_x)=',real(x_t,4),real(rex,4),real(sqrt(rex),4)
	  fg1=.false.!;call bcast(fg1, lsize)
         endif
        endif

        if(x.eq.0.0)then
         if(fg2.eqv..true.)then
          write(6,*)'Jet centerline x,Re_x,sqrt(Re_x)=',real(x_t,4),real(rex,4),real(sqrt(rex),4)
          fg2=.false.!;call bcast(fg2, lsize)
         endif
        endif

        if(x.eq.xmx)then
          if(fg3.eqv..true.)then
            write(6,*)'Outflow at x ,Re_x,sqrt(Re_x)=',real(x_t,4),real(rex,4),real(sqrt(rex),4)
          fg3=.false.!;call bcast(fg3, lsize)
         endif
        endif          
      
         eta = y*sqrt(rex)/x_t
         call blasius(ub(i),vb(i),eta,rex)

      enddo

      return
      end
c-----------------------------------------------------------------------
      real function womersley(r, t)
      common/math/api
      common/pipe/alpha,omega,radius,uo_cent
      real       r,t
      complex*16 ci,cz,cn,cd,ch,cf
      complex*16 CBJ0,CDJ0,CBJ1,CDJ1,CBY0,CDY0,CBY1,CDY1
      ci = cmplx( cos(3.0*API/4.0), sin(3.0*API/4.0) )
      cz = alpha * r * ci
      call CJY01(cz,cn,CDJ0,CBJ1,CDJ1,CBY0,CDY0,CBY1,CDY1)
      cz = alpha * ci
      call CJY01(cz,cd,CDJ0,CBJ1,CDJ1,CBY0,CDY0,CBY1,CDY1)
      ch = cmplx( cos(omega*t), sin(omega*t) )
      cf = (1.0 - cn/cd) * ch / cmplx(0.0, 1.0)
      womersley = real(cf) * uo_cent
      return
      end
c-----------------------------------------------------------------------
        SUBROUTINE CJY01(Z,CBJ0,CDJ0,CBJ1,CDJ1,CBY0,CDY0,CBY1,CDY1)
C
C       =======================================================
C       Purpose: Compute Bessel functions J0(z), J1(z), Y0(z), 
C                Y1(z), and their derivatives for a complex
C                argument
C       Input :  z --- Complex argument
C       Output:  CBJ0 --- J0(z)
C                CDJ0 --- J0'(z)
C                CBJ1 --- J1(z)
C                CDJ1 --- J1'(z)
C                CBY0 --- Y0(z)
C                CDY0 --- Y0'(z)
C                CBY1 --- Y1(z)
C                CDY1 --- Y1'(z)
C       =======================================================
C
        IMPLICIT DOUBLE PRECISION (A,B,E,P,R,W)
        IMPLICIT COMPLEX*16 (C,Z)
        DIMENSION A(12),B(12),A1(12),B1(12)
        PI=3.141592653589793D0
        EL=0.5772156649015329D0
        RP2=2.0D0/PI
        CI=(0.0D0,1.0D0)
        A0=CDABS(Z)
        Z2=Z*Z
        Z1=Z
        IF (A0.EQ.0.0D0) THEN
           CBJ0=(1.0D0,0.0D0)
           CBJ1=(0.0D0,0.0D0)
           CDJ0=(0.0D0,0.0D0)
           CDJ1=(0.5D0,0.0D0)
           CBY0=-(1.0D300,0.0D0)
           CBY1=-(1.0D300,0.0D0)
           CDY0=(1.0D300,0.0D0)
           CDY1=(1.0D300,0.0D0)
           RETURN
        ENDIF
        IF (REAL(Z).LT.0.0) Z1=-Z
        IF (A0.LE.12.0) THEN
           CBJ0=(1.0D0,0.0D0)
           CR=(1.0D0,0.0D0)
           DO 10 K=1,40
              CR=-0.25D0*CR*Z2/(K*K)
              CBJ0=CBJ0+CR
              IF (CDABS(CR).LT.CDABS(CBJ0)*1.0D-15) GO TO 15
10         CONTINUE
15         CBJ1=(1.0D0,0.0D0)
           CR=(1.0D0,0.0D0)
           DO 20 K=1,40
              CR=-0.25D0*CR*Z2/(K*(K+1.0D0))
              CBJ1=CBJ1+CR
              IF (CDABS(CR).LT.CDABS(CBJ1)*1.0D-15) GO TO 25
20         CONTINUE
25         CBJ1=0.5D0*Z1*CBJ1
           W0=0.0D0
           CR=(1.0D0,0.0D0)
           CS=(0.0D0,0.0D0)
           DO 30 K=1,40
              W0=W0+1.0D0/K
              CR=-0.25D0*CR/(K*K)*Z2
              CP=CR*W0
              CS=CS+CP
              IF (CDABS(CP).LT.CDABS(CS)*1.0D-15) GO TO 35
30         CONTINUE
35         CBY0=RP2*(CDLOG(Z1/2.0D0)+EL)*CBJ0-RP2*CS
           W1=0.0D0
           CR=(1.0D0,0.0D0)
           CS=(1.0D0,0.0D0)
           DO 40 K=1,40
              W1=W1+1.0D0/K
              CR=-0.25D0*CR/(K*(K+1))*Z2
              CP=CR*(2.0D0*W1+1.0D0/(K+1.0D0))
              CS=CS+CP
              IF (CDABS(CP).LT.CDABS(CS)*1.0D-15) GO TO 45
40         CONTINUE
45         CBY1=RP2*((CDLOG(Z1/2.0D0)+EL)*CBJ1-1.0D0/Z1-.25D0*Z1*CS)
        ELSE
           DATA A/-.703125D-01,.112152099609375D+00,
     &            -.5725014209747314D+00,.6074042001273483D+01,
     &            -.1100171402692467D+03,.3038090510922384D+04,
     &            -.1188384262567832D+06,.6252951493434797D+07,
     &            -.4259392165047669D+09,.3646840080706556D+11,
     &            -.3833534661393944D+13,.4854014686852901D+15/
           DATA B/ .732421875D-01,-.2271080017089844D+00,
     &             .1727727502584457D+01,-.2438052969955606D+02,
     &             .5513358961220206D+03,-.1825775547429318D+05,
     &             .8328593040162893D+06,-.5006958953198893D+08,
     &             .3836255180230433D+10,-.3649010818849833D+12,
     &             .4218971570284096D+14,-.5827244631566907D+16/
           DATA A1/.1171875D+00,-.144195556640625D+00,
     &             .6765925884246826D+00,-.6883914268109947D+01,
     &             .1215978918765359D+03,-.3302272294480852D+04,
     &             .1276412726461746D+06,-.6656367718817688D+07,
     &             .4502786003050393D+09,-.3833857520742790D+11,
     &             .4011838599133198D+13,-.5060568503314727D+15/
           DATA B1/-.1025390625D+00,.2775764465332031D+00,
     &             -.1993531733751297D+01,.2724882731126854D+02,
     &             -.6038440767050702D+03,.1971837591223663D+05,
     &             -.8902978767070678D+06,.5310411010968522D+08,
     &             -.4043620325107754D+10,.3827011346598605D+12,
     &             -.4406481417852278D+14,.6065091351222699D+16/
           K0=12
           IF (A0.GE.35.0) K0=10
           IF (A0.GE.50.0) K0=8
           CT1=Z1-.25D0*PI
           CP0=(1.0D0,0.0D0)
           DO 50 K=1,K0
50            CP0=CP0+A(K)*Z1**(-2*K)
           CQ0=-0.125D0/Z1
           DO 55 K=1,K0
55            CQ0=CQ0+B(K)*Z1**(-2*K-1)
           CU=CDSQRT(RP2/Z1)
           CBJ0=CU*(CP0*CDCOS(CT1)-CQ0*CDSIN(CT1))
           CBY0=CU*(CP0*CDSIN(CT1)+CQ0*CDCOS(CT1))
           CT2=Z1-.75D0*PI
           CP1=(1.0D0,0.0D0)
           DO 60 K=1,K0
60            CP1=CP1+A1(K)*Z1**(-2*K)
           CQ1=0.375D0/Z1
           DO 65 K=1,K0
65            CQ1=CQ1+B1(K)*Z1**(-2*K-1)
           CBJ1=CU*(CP1*CDCOS(CT2)-CQ1*CDSIN(CT2))
           CBY1=CU*(CP1*CDSIN(CT2)+CQ1*CDCOS(CT2))
        ENDIF
        IF (REAL(Z).LT.0.0) THEN
           IF (DIMAG(Z).LT.0.0) CBY0=CBY0-2.0D0*CI*CBJ0
           IF (DIMAG(Z).GT.0.0) CBY0=CBY0+2.0D0*CI*CBJ0
           IF (DIMAG(Z).LT.0.0) CBY1=-(CBY1-2.0D0*CI*CBJ1)
           IF (DIMAG(Z).GT.0.0) CBY1=-(CBY1+2.0D0*CI*CBJ1)
           CBJ1=-CBJ1
        ENDIF
        CDJ0=-CBJ1
        CDJ1=CBJ0-1.0D0/Z*CBJ1
        CDY0=-CBY1
        CDY1=CBY0-1.0D0/Z*CBY1
        RETURN
        END
c-----------------------------------------------------------------------

! FST FST FST !!
c----------------------------------------------------------------------
      subroutine fst 
      ! Synthethic Freestream turbulence implementation designed by M A Bucci
      ! Ref paper:
      !      
      !      
      implicit none
      include 'SIZE'
      include 'TOTAL'

      integer i,n
      real    dum(lx1*ly1*lz1*lelv),tot_deficit,xmin,xmax,delta_star
      real    glsc2,glmin,glmax
      real    dumxx(lx1*ly1*lz1*lelv)
      n = nx1*ny1*nz1*nelv

      if (istep.eq.0) then
        call oprzero(fst_uin,fst_vin,fst_win)
        call initWavenumbers
        call initModes
        call defineBC
        call interpolateModes
      endif
      call computeBC
      return
      end
c----------------------------------------------------------------------
      subroutine initWavenumbers
      implicit none
      include 'SIZE'
      include 'TOTAL'
      integer itervp, i
      character*60 filename
      itervp = 0
      do i = 1, fst_numk*fst_nmodes
        itervp = itervp + 1
        write(filename,'(A,I3.3,A)')'FST_data/wavenumber',itervp,'.dat'
        open (299, file = trim(filename), form = 'formatted', status = 'old')
        read (299,*) frec(1,i) !omega
        read (299,*)
        read (299,*) frec(2,i) !beta 
        close(299)
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine initModes
      implicit none
      include 'SIZE'
      include 'TOTAL'
      integer i,j,k,itervp
      character*60 filename
      itervp = 0
      do k = 1, fst_numk
        do j = 1, fst_nmodes
        itervp = itervp + 1
        write(filename,'(A,I3.3,A)')'FST_data/velocity',itervp,'.dat'
        open (200, file = trim(filename),form = 'formatted',status = 'unknown')
        read(200,*) npointModes
          do i = 1, npointModes
           read(200,*) umodes(i,1,itervp),umodes(i,2,itervp), umodes(i,3,itervp),
     $                 umodes(i,4,itervp), umodes(i,5,itervp),umodes(i,6,itervp), umodes(i,7,itervp)
          enddo
         close(200)
        enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine defineBC ! Define a pointer containing the points located at the inlet
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer i,j,k,e,f,i0,i1,j0,j1,k0,k1

      npointBC = 0   
      do e = 1, nelv
      do f = 1, 2*ndim

         if (cbc(f,e,1).eq.'v  ') then
          call facind(i0,i1,j0,j1,k0,k1,nx1,ny1,nz1,f)
          do i = i0, i1
          do j = j0, j1
          do k = k0, k1
            npointBC = npointBC + 1
            pointBC(npointBC,1) = i
            pointBC(npointBC,2) = j
            pointBC(npointBC,3) = k
            pointBC(npointBC,4) = e
            pointBC(npointBC,5) = xm1(i,j,k,e)
            pointBC(npointBC,6) = ym1(i,j,k,e)
            pointBC(npointBC,7) = zm1(i,j,k,e)
          enddo
          enddo
          enddo
         endif

      enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine interpolateModes
      implicit none
      include 'SIZE'
      include 'TOTAL'
      real y1(npointModes), y2(npointModes), y3(npointModes),
     $     y4(npointModes), y5(npointModes), y6(npointModes),
     $     uint1, uint2, uint3, uint4, uint5, uint6, yint
      integer itervp,kvalue,j,i

      itervp = 0
      do kvalue = 1, fst_numk
      do j = 1, fst_nmodes
      itervp = itervp + 1

c     SPLINE SECOND DERIVATE
      call spline (umodes(1,1,1),umodes(1,2,itervp),npointModes,1e30,1e30,y1(1))
      call spline (umodes(1,1,1),umodes(1,3,itervp),npointModes,1e30,1e30,y2(1))
      call spline (umodes(1,1,1),umodes(1,4,itervp),npointModes,1e30,1e30,y3(1))
      call spline (umodes(1,1,1),umodes(1,5,itervp),npointModes,1e30,1e30,y4(1))
      call spline (umodes(1,1,1),umodes(1,6,itervp),npointModes,1e30,1e30,y5(1))
      call spline (umodes(1,1,1),umodes(1,7,itervp),npointModes,1e30,1e30,y6(1))

c     INTERPOLATING VALUES   
      do i = 1, npointBC
            yint = pointBC(i,6)
            call splint(umodes(1,1,1),umodes(1,2,itervp),y1(1),npointModes,yint,uint1)
            call splint(umodes(1,1,1),umodes(1,3,itervp),y2(1),npointModes,yint,uint2)
            call splint(umodes(1,1,1),umodes(1,4,itervp),y3(1),npointModes,yint,uint3)
            call splint(umodes(1,1,1),umodes(1,5,itervp),y4(1),npointModes,yint,uint4)
            call splint(umodes(1,1,1),umodes(1,6,itervp),y5(1),npointModes,yint,uint5)
            call splint(umodes(1,1,1),umodes(1,7,itervp),y6(1),npointModes,yint,uint6)
            umodesBC(i,1,itervp) = uint1
            umodesBC(i,2,itervp) = uint2
            umodesBC(i,3,itervp) = uint3
            umodesBC(i,4,itervp) = uint4
            umodesBC(i,5,itervp) = uint5
            umodesBC(i,6,itervp) = uint6
      enddo
      enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine computeBC
      implicit none
      include 'SIZE'
      include 'TOTAL'
      real u_turbu(npointBC,3)
      integer i,j,k,e, ieg, index
      e = gllel (ieg)

      call computeTurbu(u_turbu) ! Generate the turbulent profile

      do index = 1, npointBC
         i = pointBC(index,1)
         j = pointBC(index,2)
         k = pointBC(index,3)
         e = pointBC(index,4)

         fst_uin(i,j,k,e) = u_turbu(index,1)
         fst_vin(i,j,k,e) = u_turbu(index,2)
         fst_win(i,j,k,e) = u_turbu(index,3)
      enddo

      return
      end
c---------------------------------------------------------------------
      subroutine computeTurbu(u_turbu)
      implicit none
      include 'SIZE'
      include 'TOTAL'
      real u_turbu(npointBC,3), turbu_aux(npointBC,3)
      real kk, dkk, dkke, kk1, kk2, enspect1, enspect2, integral 
      real ampli, enspect, auxcos(npointBC), auxsin(npointBC), aa, bb
      integer i, j, k, itervp, kvalue

      aa = 1.6060d0 ! von Karman Spectrum constant 1
      bb = 1.3500d0 ! von Karman Spectrum constant 2
      dkk = (fst_okfin - fst_okini)/(fst_numk-1)
      kk1 = fst_okini-dkk/2
      kk2 = fst_okfin+dkk/2
      dkke = (kk2-kk1)/fst_numk
      kk = kk1
      integral = 0.0d0

      do i = 1,fst_numk
       enspect1 = 2.0d0/3.0d0*fst_length*((aa*(kk*fst_length)**4)/(bb+(kk*fst_length)**2)**(17.0d0/6.0d0))
       kk = kk + dkke
       enspect2 = 2.0d0/3.0d0*fst_length*((aa*(kk*fst_length)**4)/(bb+(kk*fst_length)**2)**(17.0d0/6.0d0))
       integral = integral +(enspect1+enspect2)*dkke/2
      enddo
      integral = 1.0d0/integral
      itervp = 0.0d0

      call rzero(u_turbu(1,1), npointBC)
      call rzero(u_turbu(1,2), npointBC)
      call rzero(u_turbu(1,3), npointBC)

      kk = fst_okini
      do kvalue = 1,fst_numk

        do i = 1, fst_nmodes
        enspect = integral*fst_tu**2*fst_length*((aa*(kk*fst_length)**4)/(bb+(kk*fst_length)**2)**(17.0d0/6.0d0))
        ampli = sqrt(enspect*dkk/(fst_nmodes*2)*2)
        itervp = itervp + 1

        do j = 1, npointBC
                auxcos(j) = +cos(+frec(1,itervp)*time+frec(2,itervp)*pointBC(j,7))
     $                      +cos(-frec(1,itervp)*time+frec(2,itervp)*pointBC(j,7))
                auxsin(j) = -sin(+frec(1,itervp)*time+frec(2,itervp)*pointBC(j,7))
     $                      -sin(-frec(1,itervp)*time+frec(2,itervp)*pointBC(j,7))
        enddo

         call rzero(turbu_aux(1,1), npointBC)
         call addcol3(turbu_aux(1,1),umodesBC(1,1,itervp),auxcos(1),npointBC)  !a = a+b*c
         call addcol3(turbu_aux(1,1),umodesBC(1,2,itervp),auxsin(1),npointBC)
         call rzero(turbu_aux(1,2), npointBC)
         call addcol3(turbu_aux(1,2),umodesBC(1,3,itervp),auxcos(1),npointBC)
         call addcol3(turbu_aux(1,2),umodesBC(1,4,itervp),auxsin(1),npointBC)
         call rzero(turbu_aux(1,3), npointBC)
         call addcol3(turbu_aux(1,3),umodesBC(1,5,itervp),auxcos(1),npointBC)
         call addcol3(turbu_aux(1,3),umodesBC(1,6,itervp),auxsin(1),npointBC)

        call add2s2(u_turbu(1,1),turbu_aux(1,1),ampli,npointBC)
        call add2s2(u_turbu(1,2),turbu_aux(1,2),ampli,npointBC)
        call add2s2(u_turbu(1,3),turbu_aux(1,3),ampli,npointBC)

        enddo
        kk = kk + dkk
      enddo

      return
      end
c----------------------------------------------------------------------
      SUBROUTINE spline(x,y,n,yp1,ypn,y2)
      implicit none
      INTEGER i,k,n,NMAX
      REAL yp1,ypn,x(n),y(n),y2(n)
      PARAMETER (NMAX=9999)
      REAL p,qn,sig,un,u(NMAX)

      if (yp1.gt..99e30) then ! NATURAL 
         y2(1)=0.0d0
         u(1)=0.0d0
      else ! FIRST DERIVATIVE
         y2(1)=-0.5
         u (1)=(3./(x(2)-x(1)))*((y(2)-y(1))/(x(2)-x(1))-yp1)
      endif
      do  i=2,n-1
         sig=(x(i)-x(i-1))/(x(i+1)-x(i-1))
         p=sig*y2(i-1)+2.
         y2(i)=(sig-1.)/p
         u(i)=(6.*((y(i+1)-y(i))/(x(i+1)-x(i))-(y(i)-y(i-1))/(x(i)-x(i-1)))/(x(i+1)-x(i-1))-sig*u(i-1))/p
      enddo
      if (ypn.gt..99e30) then
        qn=0.0d0
        un=0.0d0
      else
        qn=0.50d0
        un=(3./(x(n)-x(n-1)))*(ypn-(y(n)-y(n-1))/(x(n)-x(n-1)))
      endif
      y2(n)=(un-qn*u(n-1))/(qn*y2(n-1)+1.)
      do  k=n-1,1,-1
      y2(k)=y2(k)*y2(k+1)+u(k)
      enddo
      return
      END
c----------------------------------------------------------------------
      SUBROUTINE splint(xa,ya,y2a,n,x,y)
      implicit none
      INTEGER n,k,khi,klo
      REAL a,b,h,x,y,xa(n),y2a(n),ya(n)
      klo=1; khi=n

1     if (khi-klo.gt.1) then
         k=(khi+klo)/2
         if(xa(k).gt.x)then
             khi=k
          else
             klo=k
          endif
      goto 1
      endif
      h=xa(khi)-xa(klo)
      if (h.eq.0.) then
         !if (nid.eq.0) print *, 'bad xa input in splint'
         call exitt
      endif
      a=(xa(khi)-x)/h
      b=(x-xa(klo))/h
      y=a*ya(klo)+b*ya(khi)+
     $        ((a**3-a)*y2a(klo)+(b**3-b)*y2a(khi))*(h**2)/6.

      return
      END
c----------------------------------------------------------------------